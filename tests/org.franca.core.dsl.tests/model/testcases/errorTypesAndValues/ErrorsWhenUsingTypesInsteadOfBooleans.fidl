package a.b.c
typeCollection TC {
	enumeration Errors {
		Error
	}
	enumeration OtherErrors {
		OtherError
	}
}
interface InterfaceTest {
	method forceEnumError {
		error TC.Errors
	}
	contract {
		vars {
			TC.Errors savedError;
			TC.OtherErrors otherError;
		}
			
		PSM {
			initial start
			state start {
				on error forceEnumError [TC.Errors.Error] -> start
				on error forceEnumError [TC.Errors] -> start
				on error forceEnumError [TC] -> start
				on error forceEnumError [errordef] -> start

				on error forceEnumError [!TC.Errors.Error] -> start
				on error forceEnumError [!TC.Errors] -> start
				on error forceEnumError [!TC] -> start
				on error forceEnumError [!errordef] -> start
								
				on error forceEnumError [errorval == TC] -> start
				on error forceEnumError [errordef == TC] -> start
				on error forceEnumError [errordef.Error == TC] -> start
				on error forceEnumError [errorval == TC.Errors] -> start
				on error forceEnumError [errordef.Error == TC.Errors] -> start
				on error forceEnumError [errorval == TC.OtherErrors] -> start
				on error forceEnumError [errordef.Error == TC.OtherErrors] -> start
				on error forceEnumError [errordef == otherError] -> start
				on error forceEnumError [errordef == savedError] -> start
				
				//this would be valid if some sort of reflection would be valid:
				on error forceEnumError [errordef == TC.Errors] -> start
				on error forceEnumError [errordef == TC.OtherErrors] -> start

			}
		}
	}
}
