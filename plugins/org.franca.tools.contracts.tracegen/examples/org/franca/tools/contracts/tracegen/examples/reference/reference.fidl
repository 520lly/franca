package org.franca.tools.contracts.tracegen.examples.reference

typeCollection MyTypes {
	
	typedef OneOrTwo is Integer(1 ,  2)
	typedef One is Integer
	
	enumeration UnusedErrors {
		UNUSED
	}
	
	enumeration BasicErrors {
		BasicError
		ErrorWithValueID = ErrorValueID
		ErrorWithStringValue = "This is the id of a basic error"
		ErrorWithValueIDSubst = ErrorWithValueID
	}
	
	enumeration ErrorsExtension extends BasicErrors {
		ExtensionsAdditionalError
	}

	struct SimpleStruct {
		UInt32 simpleStructsUInt32Value
	}
	
	struct ComplexStruct extends SimpleStruct {
		Int32 complexStructsInt32Value
	}
	
	struct VeryComplexStruct extends ComplexStruct {
		ComplexStruct complextData 
	}
	
	//TODO why are structs with self references not allowed? (larger circles are not checked) 
}

interface Reference {
	
//	attribute Int32 int32Attrib
//	attribute UInt8 uint8Attrib
//	attribute Boolean boolAttrib
//	attribute Float floatAttrib
	
	method init {}
	method reset {}
	method doSomething {}
	method addConst {}
	method addParam {
		in {UInt32 summand}
	}
//	method addParamSimpleResult {
//		in {UInt32 summand}
//		out {UInt64 result}
//	}
	method addParamComplex {
		in {MyTypes.OneOrTwo oneOrTwoSummand Integer(minInt, 42) strangeSummand Integer(42 ,42) theAnswer Int32 int32Summand Int64 int64Summand Double doubleSummand Float floatSummand}
		out {Int32 int32Result Int64 int64Result Double doubleResult Float floatResult}
	}
	method forceEnumError {
		error MyTypes.ErrorsExtension 
	}
	method forceSimpleError {
		error extends MyTypes.BasicErrors {
			additionalError
			otherError = otherErrorValue
			stringValuedError = "This is an Error with a string as its value"
		}
	}
	method subConst {}
	method multConst {}
	method divConst {}
	method equalToConst {}
	method notEqualToConst {}
	method severalBooleansConst {}
	method complexBooleans {
		in {Boolean a Boolean b}
		out {Boolean r}
	}
	method handleStringParams {
		in {String str1 String str2 String str3}
		out {String outStr1 String outStr2 String outStr3}
	}
	method handleStructs {
		in { MyTypes.SimpleStruct simple MyTypes.ComplexStruct complex}
		out { MyTypes.VeryComplexStruct veryComplex }
	}
	
	
	contract {
		
		vars {
			Integer(minInt, maxInt) interval;
			Boolean isTheWeatherFine;
			UInt32 aNumber;
			Float aFloat;
			Double aDouble;
			String aString;
			MyTypes.VeryComplexStruct aComplexStruct;
			MyTypes.BasicErrors lastBasicError;
//			forceSimpleError.error lastImplicitErrorTypeError;
		}
		PSM {
			initial Idle
			
			state Idle {
				on call init -> testingStructs {//testingAddConst {
					isTheWeatherFine = false
					aNumber = 0
					//aFloat = 1.0f
					aDouble = -1.1234e-12d
					aString = ""
				}
			}
			
			state testingAddConst {
				on call addConst [aNumber < 3] -> testingAddConst {
					aNumber = aNumber + 1
				}
				on call addConst [aNumber >= 3] -> testingSubConst
			}
			state testingSubConst {
				on call subConst [aNumber > 1] -> testingSubConst {
					aNumber = aNumber - 1
				}
				on call subConst [aNumber == 1] -> testingMultConst
			}
			state testingMultConst {
				on call multConst [aNumber < 8] -> testingMultConst {
					aNumber = aNumber * 2
				}
				on call multConst [aNumber == 8] -> testingDivConst
			}
			state testingDivConst {
				on call divConst [aNumber > 1] -> testingDivConst {
					aNumber = aNumber / 2
				}
				on call divConst [aNumber == 1] -> testingEqualToConst
			}
			state testingEqualToConst {
				on call equalToConst [isTheWeatherFine == false] -> testingEqualToConst {
					isTheWeatherFine = isTheWeatherFine == false
				}
				on call equalToConst [isTheWeatherFine == true] -> testingNotEqualToConst {
					isTheWeatherFine = isTheWeatherFine == false
				}
			}
			state testingNotEqualToConst {
				on call notEqualToConst [isTheWeatherFine == true] -> testingNotEqualToConst {
					isTheWeatherFine = isTheWeatherFine == false
				}
				on call notEqualToConst [isTheWeatherFine == false] -> testingSeveralBooleansConst
			}
			state testingSeveralBooleansConst {
				on call severalBooleansConst [false] -> testingSeveralBooleansConst
				on call severalBooleansConst [true] -> testingSeveralParameterizedCalls {
					isTheWeatherFine = false || isTheWeatherFine && aNumber < 10
				}
				on call severalBooleansConst [true] -> testDone //this should never been called
			}
			
			/////////////////
			
			state testingSeveralParameterizedCalls {
				on call addParam [ aNumber >= 5 || aNumber <= -5] -> testingComplexBooleans
				on call addParam [ summand < 5 ] -> testingSeveralParameterizedCalls {
					aNumber = aNumber + summand
				}
				//there might be calls here that will be ignored!!!
				on call addParam [true] -> testingComplexParameterizedCalls
			}
			state testingComplexParameterizedCalls {
				on call addParamComplex [int32Summand > 0 ] -> testingComplexBooleans {
					aNumber = int32Summand * (0 + 1)
				}
				on call addParamComplex [int32Summand == 0 ] -> testingComplexBooleans {
					aNumber = int32Summand * (0 + 1)
				}
				on call addParamComplex -> testingComplexParameterizedCalls //implicit else
			}
			state testingComplexBooleans {
				on call complexBooleans [ a ] -> testingComplexBooleans {
					isTheWeatherFine = b
				}
				on call complexBooleans [ b ] -> testingComplexBooleans {
					isTheWeatherFine = b
				}
				on respond complexBooleans [ r ] -> testingStringParams
			}
			state testingStringParams {
				on call handleStringParams [aString != "" && str2 == "test"] -> testingStructs  {
					aString = ""
					aString = aString
					aString = str1
					isTheWeatherFine = "sunshine" == str3
					// aString = str1 + str2 + str3
				}
				on respond handleStringParams -> testingStructs {
					aString = outStr1
				}
			}
			
			state testingStructs {
				on call handleStructs -> testDone {
					aComplexStruct.complextData.complexStructsInt32Value = 99
					//aComplexStruct.complextData.complexStructsInt32Value = simple.simpleStructsUInt32Value
					//aComplexStruct.complextData.complexStructsInt32Value = aComplexStruct.complextData.complexStructsInt32Value + 99
				}
				/*
				on call handleStructs [simple.simpleStructsUInt32Value < 1] -> testingStructs {
					aNumber = simple.simpleStructsUInt32Value
				}
				on call handleStructs [aComplexStruct.complextData.complexStructsInt32Value <= 2] -> testingStructs {
					aNumber = aComplexStruct.complextData.complexStructsInt32Value
				}
				on call handleStructs [ simple.simpleStructsUInt32Value < 3 && aComplexStruct.complextData.complexStructsInt32Value <= 4] -> testingStructs {
					aComplexStruct.complextData.complexStructsInt32Value = aComplexStruct.complextData.complexStructsInt32Value + 5
				}
				
				on call handleStructs [ complex.complexStructsInt32Value < 6 ] -> testingStructs
				on respond handleStructs [ veryComplex.complextData.complexStructsInt32Value < 7 ] -> testingStructs

				on respond handleStructs [ veryComplex.complextData.simpleStructsUInt32Value < 8 ] -> testingStructs
				*/
				/*
				on call handleStructs -> testingErrors
				on respond handleStructs -> testingErrors
				*/
			}
			
			state testingErrors {
				on error forceEnumError [  errordef.ExtensionsAdditionalError == errorval] -> testingStatements
				on error forceSimpleError [ errordef.additionalError == errorval ] -> testingStatements
				on error forceSimpleError [ lastBasicError ==  MyTypes.BasicErrors.BasicError  ] -> testingStatements
				on respond forceEnumError -> testingStatements
			}
			
			////////////////
			
//			state testingSetAttributes {
//				on set boolAttrib -> testingStatements
//			}

			state testingStatements {
				on call doSomething -> testDone {
					if (true) {
						if (false) {
							isTheWeatherFine = false
						} else if (! isTheWeatherFine) {
							isTheWeatherFine = true
						}
						if (false || isTheWeatherFine) {
							isTheWeatherFine = false
						}
					}
				}
			}
			
			state testDone {
				on call reset -> Idle
			}
			
		}
	
	}
	enumeration LocalEnum {
		LocalError
	}
}
