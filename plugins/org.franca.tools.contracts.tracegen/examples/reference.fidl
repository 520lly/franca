package org.franca.tools.contracts.tracegen.examples.reference

typeCollection MyTypes {
	
	enumeration BasicErrors {
		BasicError
		ErrorWithValueID = ErrorValueID
		ErrorWithStringValue = "This is the id of a basic error"
		ErrorWithValueIDSubst = ErrorWithValueID
	}
	
	enumeration ErrorsExtension extends BasicErrors {
		AdditionalsError
	}

}

interface Reference {
	
//	attribute Int32 int32Attrib
//	attribute UInt8 uint8Attrib
//	attribute Boolean boolAttrib
//	attribute Float floatAttrib
	
	method init {}
	method reset {}
	method addConst {}
	method addParam {
		in {UInt32 summand}
	}
//	method addParamSimpleResult {
//		in {UInt32 summand}
//		out {UInt64 result}
//	}
//	method addParamComplex {
//		in {Int32 int32Summand Int64 int64Summand Double doubleSummand Float floatSummand}
//		out {Int32 int32Result Int64 int64Result Double doubleResult Float floatResult}
//	}
//	method addParramDefective {
//		error {
//			additionError
//			otherError = otherErrorValue
//			stringValuedError = "This is an Error with a string as its value"
//		}
//	}
	method subConst {}
	method multConst {}
	method divConst {}
	method equalToConst {}
	method notEqualToConst {}
	method severalBooleansConst {}
//	method complexBooleans {
//		in {Boolean a Boolean b}
//		out {Boolean r}
//		error {ErrorWithComplexBooleans}
//	}
//	method handleStringParams {
//		in {String str1 String str2 String str3}
//		out {String outStr1 String outStr2 String outStr3}
//	}
//	method handleAllNumbers {
//		
//	}
	
	contract {
		vars {
			Boolean isTheWeatherFine;
			UInt32 aNumber;
			Double aDouble;
			Double aFloat;
			String aString;
		}
		PSM {
			initial Idle
			
			state Idle {
				on call init -> testingAddConst {
					isTheWeatherFine = false
					aNumber = 0
				}
			}
			state testingAddConst {
				on call addConst [aNumber < 3] -> testingAddConst {
					aNumber = aNumber + 1
				}
				on call addConst [aNumber >= 3] -> testingSubConst
			}
			state testingSubConst {
				on call subConst [aNumber > 1] -> testingSubConst {
					aNumber = aNumber - 1
				}
				on call subConst [aNumber == 1] -> testingMultConst
			}
			state testingMultConst {
				on call multConst [aNumber < 8] -> testingMultConst {
					aNumber = aNumber * 2
				}
				on call multConst [aNumber == 8] -> testingDivConst
			}
			state testingDivConst {
				on call divConst [aNumber > 1] -> testingDivConst {
					aNumber = aNumber / 2
				}
				on call divConst [aNumber == 1] -> testingEqualToConst
			}
			state testingEqualToConst {
				on call equalToConst [isTheWeatherFine == false] -> testingEqualToConst {
					isTheWeatherFine = isTheWeatherFine == false
				}
				on call equalToConst [isTheWeatherFine == true] -> testingNotEqualToConst {
					isTheWeatherFine = isTheWeatherFine == false
				}
			}
			state testingNotEqualToConst {
				on call notEqualToConst [isTheWeatherFine == true] -> testingNotEqualToConst {
					isTheWeatherFine = isTheWeatherFine == false
				}
				on call notEqualToConst [isTheWeatherFine == false] -> testingSeveralBooleansConst
			}
			state testingSeveralBooleansConst {
				on call severalBooleansConst [false] -> testingSeveralBooleansConst
				on call severalBooleansConst [true] -> testDone {
					isTheWeatherFine = false || isTheWeatherFine && aNumber < 10
				}
				on call severalBooleansConst [true] -> testingSeveralParameterizedCalls
			}
			
			/////////////////
			
			state testingSeveralParameterizedCalls {
				on call addParam [ summand < 5 ] -> testingSeveralParameterizedCalls {
					aNumber = aNumber + summand
				}
				on call addParam [ summand >= 5 ] -> testDone
			}
			
			////////////////
			
//			state testingSetAttributes {
//				on set boolAttrib -> testDone
//			}
			
			state testDone {
				on call reset -> Idle
			}
			
		}
	}
}