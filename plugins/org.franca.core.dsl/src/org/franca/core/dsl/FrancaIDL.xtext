/*******************************************************************************
* Copyright (c) 2012 Harman International (http://www.harman.com).
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* 2012-01-16: Klaus Birken (initial version)
*******************************************************************************/
grammar org.franca.core.dsl.FrancaIDL with org.eclipse.xtext.common.Terminals 

// the Franca ecore model (it is not generated from this grammar)
import "http://core.franca.org" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


// **************************************************************
// model root

FModel returns FModel:
	{FModel}
	'package' name=FQN
	(imports+=Import)*
	( typeCollections+=FTypeCollection | interfaces+=FInterface	)*;


// **************************************************************
// type collection and interface

FTypeCollection returns FTypeCollection:
	(comment=FAnnotationBlock)?
	'typeCollection' name=FQN
	'{'
		('version' version=FVersion)?
		(types+=FType)*
	'}';

FInterface returns FInterface:
	{FInterface}
	(comment=FAnnotationBlock)?
	'interface' name=FQN ('extends' base=[FInterface|FQN])?
	'{'
		('version' version=FVersion)?
		(attributes+=FAttribute)*
		(methods+=FMethod)*
		(broadcasts+=FBroadcast)*
		(contract=FContract)?
		(types+=FType)*
    '}';

FVersion returns FVersion:
	{FVersion}
	'{'
		'major' major=EInt
		'minor' minor=EInt
    '}';


// **************************************************************
// attributes

FAttribute:
	(comment=FAnnotationBlock)?
	'attribute'	type=FTypeRef (array='[]')? name=EString
		(readonly='readonly')?
		(noSubscriptions='noSubscriptions')?
	;


// **************************************************************
// methods / broadcasts

FMethod returns FMethod:
	{FMethod}
	(comment=FAnnotationBlock)?
	'method' name=EString (fireAndForget='fireAndForget')?
	'{'
		('in' '{' (inArgs+=FArgument)* '}' )?
		('out' '{' (outArgs+=FArgument)* '}' )?
		('error'
			( errorEnum=[FEnumerationType|FQN] |
			  errors=FEnumerationTypeBody )
		)?
    '}';


FBroadcast returns FBroadcast:
	{FBroadcast}
	(comment=FAnnotationBlock)?
	'broadcast' name=EString (selective='selective')?
	'{'
		('out' '{' (outArgs+=FArgument)* '}' )?
    '}';

FArgument:
	(comment=FAnnotationBlock)?
	type=FTypeRef (array='[]')? name=EString;


// **************************************************************
// type system

FTypeRef returns FTypeRef:
	predefined=FBasicTypeId | derived=[FType|FQN]
	;

enum FBasicTypeId returns FBasicTypeId:
	undefined = 'undefined' |
	Int8 = 'Int8' |
	UInt8 = 'UInt8' |
	Int16 = 'Int16' |
	UInt16 = 'UInt16' |
	Int32 = 'Int32' |
	UInt32 = 'UInt32' |
	Int64 = 'Int64' |
	UInt64 = 'UInt64' |
	Boolean = 'Boolean' |
	String = 'String' |
	Float = 'Float' |
	Double = 'Double' |
	ByteBuffer = 'ByteBuffer' ;

FType returns FType:
	FArrayType |
	FEnumerationType |
	FStructType |
	FUnionType |
	FMapType |
	FTypeDef;

FArrayType returns FArrayType:
	{FArrayType}
	(comment=FAnnotationBlock)?
	'array' name=EString 'of' elementType=FTypeRef;

FTypeDef returns FTypeDef:
	{FTypeDef}
	(comment=FAnnotationBlock)?
	'typedef' name=EString 'is' actualType=FTypeRef
	; 

FStructType returns FStructType:
	{FStructType}
	(comment=FAnnotationBlock)?
	'struct' name=EString ('extends' base=[FStructType|FQN])?
	'{'
		(elements+=FField)*
    '}';

FUnionType returns FUnionType:
	{FUnionType}
	(comment=FAnnotationBlock)?
	'union' name=EString ('extends' base=[FUnionType|FQN])?
	'{'
		(elements+=FField)*
    '}';

FEnumerationType returns FEnumerationType:
	{FEnumerationType}
	(comment=FAnnotationBlock)?
	'enumeration' name=EString
	('extends' base=[FEnumerationType|FQN])?
	'{'
		(enumerators+=FEnumerator)*
    '}';

FEnumerationTypeBody returns FEnumerationType:
	{FEnumerationType}
	('extends' base=[FEnumerationType|FQN])?
	'{'
		(enumerators+=FEnumerator)*
    '}';

FEnumerator returns FEnumerator:
	{FEnumerator}
	(comment=FAnnotationBlock)?
	name=EString ('=' value=EString)?
    ;
    
FMapType returns FMapType:
	{FMapType}
	(comment=FAnnotationBlock)?
	'map' name=EString '{'
		keyType=FTypeRef 'to' valueType=FTypeRef
	'}';

FField:
	(comment=FAnnotationBlock)?
	type=FTypeRef (array='[]')? name=EString;


FDeclaration:
	type=FTypeRef (array='[]')? name=EString;

FTypedElement:
	FField |
	FAttribute |
	FArgument |
	FDeclaration;


// **************************************************************
// interface contract

FContract:
	{FContract}
	'contract' '{'
		('vars' '{' (variables+=FDeclaration ';')* '}')?
		'PSM' stateGraph=FStateGraph
	'}';

FStateGraph:
	{FStateGraph} '{'
		'initial' initial=[FState|ID]
		states+=FState*
	'}';

FState:
	{FState}
	(comment=FAnnotationBlock)?
	'state' name=EString '{'
		transitions+=FTransition*
	'}';

FTransition:
	'on' trigger=FTrigger
		(guard=FGuard)?
		'->' to=[FState|ID]
		(action=FBlockExpression)?
	;


FTrigger:
	event=FEventOnIf;

FEventOnIf:
	('call'    call=[FMethod|EString]      ) |
	('respond' respond=[FMethod|EString]   ) |
	('signal'  signal=[FBroadcast|EString] ) |
	('set'     set=[FAttribute|EString]    ) |
	('update'  update=[FAttribute|EString] )
;

FGuard:
	'[' condition=LogicalOrExpression ']';

	
FExpression returns FExpression:
	FAssignment;

FAssignment returns FExpression:
	{FAssignment}
	lhs=[FDeclaration|ID] '=' rhs=LogicalOrExpression;

FBlockExpression returns FExpression: 
	{FBlockExpression}
	'{'
		(expressions+=FExpression)*
	'}';

LogicalOrExpression returns FExpression:
  LogicalAndExpression
  ({FBinaryOperation.left=current} op='||' right=LogicalAndExpression)*;

LogicalAndExpression returns FExpression:
  EqualityExpression
  ({FBinaryOperation.left=current} op='&&' right=EqualityExpression)*;

EqualityExpression returns FExpression:
  RelationalExpression
  ({FBinaryOperation.left=current} op=('=='|'!=') right=RelationalExpression)*;

RelationalExpression returns FExpression:
  AdditiveExpression
  ({FBinaryOperation.left=current} op=('<'|'>'|'<='|'>=') right=AdditiveExpression)*;

AdditiveExpression returns FExpression:
  MultiplicativeExpression
  ({FBinaryOperation.left=current} op=('+'|'-') right=MultiplicativeExpression)*;

MultiplicativeExpression returns FExpression:
  PrimaryExpression
  ({FBinaryOperation.left=current} op=('*'|'/') right=PrimaryExpression)*;

PrimaryExpression returns FExpression:
  FTypedElementRef |
  FConstant |
  '(' FExpression ')';

FTypedElementRef returns FExpression:
	{FTypedElementRef}
	element=[FTypedElement|EString];

FConstant returns FExpression:
	FIntegerConstant;

FIntegerConstant:
	val=EInt;


// **************************************************************
// annotations

FAnnotationBlock returns FAnnotationBlock:
	'<**' (elements+=FAnnotation)+ '**>';

FAnnotation returns FAnnotation:
	type=FAnnotationType comment=CommentString;

enum FAnnotationType returns FAnnotationType:
	undefined = 'undefined' |
	description = '@description' |
	author = '@author' |
	experimental = '@experimental' |
	deprecated = '@deprecated' |
	see = '@see' |
	param = '@param' |
	high_volume = '@high-volume' |
	high_frequency = '@high-frequency' |
	source_uri = '@source-uri' | 
	source_alias = '@source-alias' | 
	details = '@details'
	;


// **************************************************************
// basic types

EString returns ecore::EString:
	STRING | ID;

EInt returns ecore::EInt:
	'-'? INT;

terminal CommentString returns ecore::EString:
	':' ( ('\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\')) | !('\\'|'*'|'@') )*
;

// **************************************************************
// general

// HOWTO: use a combination of URI global scopes and namespace aware local scope provider
// this is configured in the work flow by
//			fragment = scoping.ImportURIScopingFragment {}
// and by overriding configureIScopeProviderDelegate in the runtime module with 
//			ImportedNamespaceAwareLocalScopeProvider
// the attribute 'importedNamespace' is picked up by the ImportedNamespaceAwareLocalScopeProvider
// the attribute 'importURI' is picked up by the ImportUriGlobalScopeProvider
// THANKS to www.eclipse.org/etrice for this solution!
Import :
	'import' (importedNamespace=ImportedFQN 'from' | 'model') importURI=STRING;

ImportedFQN:
	FQN ('.' '*')?;

FQN:
	ID ('.' ID)*;


// **************************************************************
