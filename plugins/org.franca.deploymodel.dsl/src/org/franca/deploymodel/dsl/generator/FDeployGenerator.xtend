/*******************************************************************************
* Copyright (c) 2015 itemis AG (http://www.itemis.de).
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
package org.franca.deploymodel.dsl.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.franca.deploymodel.dsl.fDeploy.FDDeclaration
import org.franca.deploymodel.dsl.fDeploy.FDEnumType
import org.franca.deploymodel.dsl.fDeploy.FDPropertyDecl
import org.franca.deploymodel.dsl.fDeploy.FDPropertyHost
import org.franca.deploymodel.dsl.fDeploy.FDSpecification
import org.franca.deploymodel.dsl.generator.internal.HelperGenerator
import org.franca.deploymodel.dsl.generator.internal.IDataGenerator
import org.franca.deploymodel.dsl.generator.internal.ImportManager
import org.franca.deploymodel.dsl.generator.internal.InterfaceAccessorGenerator
import org.franca.deploymodel.dsl.generator.internal.OverwriteAccessorGenerator
import org.franca.deploymodel.dsl.generator.internal.TypeCollectionAccessorGenerator

import static extension org.franca.deploymodel.dsl.generator.internal.GeneratorHelper.*

/**
 * Generator for PropertyAccessor class from deployment specification.
 * The deployment specification is defined as fdepl model (spec part).
 * 
 * The accessor classes generated by this generator will be useful when
 * traversing a fidl model and getting the deployment properties for this
 * model.
 */
class FDeployGenerator implements IGenerator {
	
	@Inject extension ImportManager
	
	@Inject IDataGenerator genInterface
	@Inject HelperGenerator genHelper
	@Inject TypeCollectionAccessorGenerator genTCAcc
	@Inject InterfaceAccessorGenerator genInterfaceAcc
	@Inject OverwriteAccessorGenerator genOverwriteAcc
	
	// the types of PropertyAccessor classes we can generate
	final static String PA_PROVIDER = "Provider"
	final static String PA_INTERFACE = "Interface"
	final static String PA_TYPE_COLLECTION = "TypeCollection"
	
	// the main function for this generator, will be called by Xtend framework
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(m : resource.allContents.toIterable.filter(typeof(FDSpecification))) {
			// generate compound accessor class with several nested classes
			fsa.generateAll(m)
			
			// generate some legacy classes for backward-compatibility
			// (this is needed for Franca 0.9.1 and earlier)
			fsa.generateLegacy(m, PA_PROVIDER)
			fsa.generateLegacy(m, PA_INTERFACE)
			fsa.generateLegacy(m, PA_TYPE_COLLECTION)
		}
	}
	
	
	// *****************************************************************************
	// top-level generation and analysis
	
	def generateAll (IFileSystemAccess fsa, FDSpecification spec) {
		initImportManager

		// generate class code and analyse for needed preliminaries
		val path = spec.getPackage().replace(".", "/")
		val code = spec.generateCombinedClass.toString
		var header = spec.generateHeader(false).toString
		
		fsa.generateFile(path + "/" + spec.classname + ".java", header + code)
	}
	
	def private generateCombinedClass(FDSpecification spec) '''
		public class «spec.classname» {

			«genInterface.generate(spec)»

			«genHelper.generate(spec)»

			«genTCAcc.generate(spec)»

			«genInterfaceAcc.generate(spec)»

			«genOverwriteAcc.generate(spec)»
		}
			
	'''
	

	/**
	 * Generate legacy classes needed for users of Franca 0.9.1 and earlier.
	 */
	def generateLegacy (IFileSystemAccess fsa, FDSpecification spec, String type) {
		// generate class code and analyse for needed preliminaries
		val path = spec.getPackage().replace(".", "/")
		val code = spec.generateLegacyClass(type).toString
		var header = spec.generateHeader(true).toString
		
		fsa.generateFile(path + "/" + spec.getLegacyClassname(type) + ".java", header + code)
	}
	
	
	def generateHeader (FDSpecification spec, boolean isLegacy) '''
		/*******************************************************************************
		* This file has been generated by Franca's FDeployGenerator.
		* Source: deployment specification '«spec.name»'
		*******************************************************************************/
		«IF ! spec.getPackage.empty»
		package «spec.getPackage»;
		
		«ENDIF»
		«IF !isLegacy»
		«genImports»
		«ENDIF»

	'''


	def generateLegacyClass (FDSpecification spec, String type) '''
		/**
		 * Accessor for deployment properties for '«spec.name»' specification
		 *
		 * @deprecated use class «spec.name».«type»PropertyAccessor instead
		 */
		public class «spec.getLegacyClassname(type)» extends «spec.name».«type»PropertyAccessor { }
		   
	'''

//		private «supportingClass» target;
//	
//		public «spec.classname» («supportingClass» target) {
//			«IF spec.base!=null»
//			super(target);
//			«ENDIF»
//			this.target = target;
//		}


	// *****************************************************************************
	// property generation

//	def genProperty (FDPropertyDecl it, FDPropertyHost host) {
//		switch(paType){
//			case PA_PROVIDER:
//				switch (host) {
//					case FDPropertyHost::PROVIDERS:     genGetter("FDProvider")
//					case FDPropertyHost::INSTANCES:     genGetter("FDInterfaceInstance")
//					default: ""  // ignore all other hosts
//				}
//			case PA_INTERFACE:{
//				switch (host) {
//					case FDPropertyHost::PROVIDERS:     ""  // ignore
//					case FDPropertyHost::INSTANCES:     ""  // ignore
//					case FDPropertyHost::TYPE_COLLECTIONS: genGetter("FTypeCollection")
//					case FDPropertyHost::INTERFACES:    genGetter("FInterface")
//					case FDPropertyHost::ATTRIBUTES:    genGetter("FAttribute")
//					case FDPropertyHost::METHODS:       genGetter("FMethod")
//					case FDPropertyHost::BROADCASTS:    genGetter("FBroadcast")
//					case FDPropertyHost::ARGUMENTS:     genGetter("FArgument")
//					//case FDPropertyHost::NUMBERS:       genGetter("FArgument")
//					//case FDPropertyHost::FLOATS:        genGetter("FArgument")
//					//case FDPropertyHost::INTEGERS:      genGetter("FArgument")
//					//case FDPropertyHost::STRINGS:       genGetter("FArgument")
//					case FDPropertyHost::STRUCT_FIELDS: genGetter("FField")
//					case FDPropertyHost::ENUMERATIONS:  genGetter("FEnumerationType")
//					case FDPropertyHost::ENUMERATORS:   genGetter("FEnumerator")
//					//case FDPropertyHost::ARRAYS:        genGetter("FArgument")
//					default: genGetter("EObject")  // reasonable default
//				}	
//			}
//			case PA_TYPE_COLLECTION:{
//				switch (host) {
//					case FDPropertyHost::PROVIDERS:     ""  // ignore
//					case FDPropertyHost::INSTANCES:     ""  // ignore
//					case FDPropertyHost::TYPE_COLLECTIONS: genGetter("FTypeCollection")
//					case FDPropertyHost::INTERFACES:    genGetter("FInterface")
//					case FDPropertyHost::ATTRIBUTES:    ""
//					case FDPropertyHost::METHODS:       ""
//					case FDPropertyHost::BROADCASTS:    "" // 
//					case FDPropertyHost::ARGUMENTS:     "" // only broadcasts and methods have arguments
//					//case FDPropertyHost::NUMBERS:       genGetter("FArgument")
//					//case FDPropertyHost::FLOATS:        genGetter("FArgument")
//					//case FDPropertyHost::INTEGERS:      genGetter("FArgument")
//					//case FDPropertyHost::STRINGS:       genGetter("FArgument")
//					case FDPropertyHost::STRUCT_FIELDS: genGetter("FField")
//					case FDPropertyHost::ENUMERATIONS:  genGetter("FEnumerationType")
//					case FDPropertyHost::ENUMERATORS:   genGetter("FEnumerator")
//					//case FDPropertyHost::ARRAYS:        genGetter("FArgument")
//					default: genGetter("EObject")  // reasonable default
//				}	
//			}
//		}
//	}	
//	
//
//	def genGetter (FDPropertyDecl it, String fType) {
//		neededFrancaTypes.add(fType)
//		if (type.complex!=null) {
//			val ct = type.complex			
//			switch (ct) {
//				FDEnumType: genEnumGetter(ct, fType)
//				default:    genDefaultGetter(fType)
//			}
//		} else {
//			genDefaultGetter(fType)
//		}
//	}
//
//	def genDefaultGetter (FDPropertyDecl it, String fType) '''
//		public «type.javaType» get«name.toFirstUpper» («fType» obj) {
//			return target.get«type.getter»(obj, "«name»");
//		}
//
//	'''
//	
//	def genEnumGetter (FDPropertyDecl it, FDEnumType enumerator, String fType) {
//		neededFrancaTypes.add(fType)
//		val etname = name.toFirstUpper
//		val lname =
//			if (type.array==null) {
//				etname
//			} else {
//				setNeedArrayList
//				etname.genListType
//			}
//		
//		'''
//			public enum «etname» {
//				«FOR e : enumerator.enumerators SEPARATOR ", "»«e.name»«ENDFOR»
//			}
//			public «lname» get«name.toFirstUpper» («fType» obj) {
//				«type.javaType» e = target.get«type.getter»(obj, "«etname»");
//				if (e==null) return null;
//				«IF it.type.array!=null»
//				List<«etname»> es = new ArrayList<«etname»>();
//				for(String ev : e) {
//					«etname» v = convert«etname»(ev);
//					if (v==null) {
//						return null;
//					} else {
//						es.add(v);
//					}
//				}
//				return es;
//				«ELSE»
//				return convert«etname»(e);
//				«ENDIF»
//			}
//			private «etname» convert«etname» (String val) {
//				«FOR e : enumerator.enumerators SEPARATOR " else "»
//				if (val.equals("«e.name»"))
//					return «etname».«e.name»;
//				«ENDFOR»
//				return null;
//			}
//			
//		'''
//	}

		

	// *****************************************************************************
	// basic helpers

		
	def private getPackage (FDSpecification it) {
		val sep = name.lastIndexOf(".")
		if (sep>0)
			name.substring(0, sep)
		else
			""
	}

	def private classname (FDSpecification it) {
		val sep = name.lastIndexOf(".")
		val basename = if (sep>0) name.substring(sep+1) else name
		basename.toFirstUpper
	}
	
	def private getLegacyClassname (FDSpecification it, String type) {
		val sep = name.lastIndexOf(".")
		val basename = if (sep>0) name.substring(sep+1) else name
		basename.toFirstUpper + type + "PropertyAccessor"
	}

//	def getSupportingClass() {
//		switch (paType) {
//			case PA_TYPE_COLLECTION: "FDeployedTypeCollection"
//			case PA_INTERFACE: "FDeployedInterface"
//			case PA_PROVIDER: "FDeployedProvider"
//			default: ""
//		}
//	}
}
