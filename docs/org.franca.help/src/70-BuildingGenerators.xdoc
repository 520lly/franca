chapter:BuildingGenerators[Building generators with Franca]

When a company or R&D department decides to model its interfaces
with Franca IDL then typically the interface definitions will be
utilized by downstream tools, mostly by generators creating code
or documentation from these interfaces.
This chapter gives an introduction how generators can be implemented 
which produce code and other artifacts from Franca IDL models.


section:BuildingGenerators_Introduction[Introduction]

This introductory section describes the basic approach and some design 
decisions how to build generators based on the Franca model API.  

section2:BuildingGenerators_Introduction_Approach[Basic approach]

A typical approach to implement generators for Franca includes the
following steps:

ol[
	item[Load a Franca IDL file (with suffix e[.fidl]) from file system.
         Result: a Franca model in main memory.]
	item[Generate code from the Franca model.
         Result: some text strings containing the generation output.]
    item[Save the generation output to one or more files on the file system.]
]

These steps will be described in more detail below.


section2:BuildingGenerators_Introduction_Language[Which language can be used?]

The loading step will result in an underlying Franca model which is the 
base for the generator. This model provides a ref:FrancaModelAPI[Java API]
generated by the
link[http://www.eclipse.org/modeling/emf/][Eclipse Modeling Framework (EMF)].

Thus, Java is a good choice for the generator implementation. However, there
are other languages available which operate on the Java VM or which translate
to Java: Groovy, Scala and Xtend are some examples. All those languages can
be used to implement generators for Franca.

For developers already used to Java we recommend using
link[http://xtend-lang.org][Xtend] for this task.
Xtend offers a seamless integration with Java allowing the generator 
being implemented as a proper mix of Java (where necessary) and Xtend.
We fill focus on Xtend in this and later chapters; the examples being
shipped with Franca are using Xtend as well.  


section2:BuildingGenerators_Introduction_ToolIntegration[Tool integration]

There are various ways to integrate a generator into your toolchain.
Here are some examples:

ul[
	item[e[Generator as JUnit test case]. Usually, this is the first step
	     when implementing a new generator. In this case, the generator
	     runs on a separate Java VM without an instance of the Eclipse IDE.]
	item[e[Standalone generator]. The generator is packed into a jar file
	     and called by a Java main class which offers command-line arguments
	     for configuring the generator. Also in this case, the generator
	     runs on a separate Java VM without an instance of the Eclipse IDE.
	     A standalone generator can also be integrated into some build process,
	     e.g. to be part of a continuous integration build.]
	item[e[Generator as Eclipse action]. The generator is embedded into
	     an e[Action] class which implements e[org.eclipse.ui.IActionDelegate].
	     Thus, the generator can be triggered from the Eclipse IDE, e.g. by 
	     selecting a proper context menu item.]
]

As this chapter puts its focus on the actual generation step, we only 
describe the JUnit-based solution here. 

todo[Explain how generators can be build in general using the Franca Model API
and how Xtend can be used to do this effectively. Give examples.]


section2:BuildingGenerators_Introduction_LoadingFrancaFile[Loading a Franca IDL file]

Loading a Franca IDL model file (with extension e[fidl]) from the file system is
a standard task. It is supported by the Franca Framework, here is a Java example:

code[Java][
import static org.junit.Assert.*;
import org.franca.core.dsl.FrancaIDLHelpers;
import org.franca.core.franca.FModel;
import org.junit.Test;

public class MyTest {
	@Test
	public void loadModel() {
		FModel fmodel = FrancaIDLHelpers.instance().loadModel("example.fidl");
		assertNotNull(fmodel);
		
		// ... traverse model here
	}
}
] 

The e[FrancaIDLHelpers] singleton class provides a convenient e[loadModel()] 
function which loads the Franca IDL file. It might use a relative or absolute
path. If the model e[imports] other files, those will be loaded, too.
All cross references will be resolved. 
The function e[loadModel()] returns an object of type
ref:FrancaModelAPIReference_FModel[FModel] (follow the link to the 
corresponding section of the ref:FrancaModelAPI[Franca Model API] documentation).


section:BuildingGenerators_TraversingFrancaModels[Traversing Franca models]

The following Xtend example code shows how to traverse all methods 
(i.e., ref:FrancaModelAPIReference_FMethod[FMethod] members) of a Franca interface
ref:FrancaModelAPIReference_FInterface[FInterface].
It generates a C++ class with member function declarations for all Franca methods.

code[Xtend][
class ExampleGenerator {
	def generateInterface (FInterface api) '''
		class «api.classname»
		{
		public:
			// methods
			«FOR m : api.methods»
			«m.generateMethodDecl» 
			«ENDFOR»
		};
	'''
}
]

This example will be detailed further soon.


section:BuildingGenerators_AccessingFrancaDeploymentModels[Accessing Franca deployment models]

For initial information on how to access Franca deployment models
please refer to section ref:DeploymentModels_GeneratorSupport[Generator support for deployment].

More detailed explanations will be added here soon. 


