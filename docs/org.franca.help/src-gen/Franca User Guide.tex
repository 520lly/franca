\documentclass[a4paper,10pt]{scrreprt}

\typearea{12}

\usepackage[T1]{fontenc}
\usepackage{ae,aecompl,aeguill} 
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{booktabs}
\usepackage[american]{babel}

\usepackage{todonotes}

\usepackage{titlepic}

\makeatletter
\renewcommand\subsection{\medskip\@startsection{subsection}{2}{\z@}%
  {-.25ex\@plus -.1ex \@minus -.2ex}%
  {1.5ex \@plus .2ex \@minus -.4ex}%
  {\ifnum \scr@compatibility>\@nameuse{scr@v@2.96}\relax
    \setlength{\parfillskip}{\z@ plus 1fil}\fi
    \raggedsection\normalfont\sectfont\nobreak\size@subsection
  }%
}
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
  {-3.25ex\@plus -1ex \@minus -.2ex}%
  {1.5ex \@plus .2ex}%
  {\sffamily\normalsize\bfseries}}
\makeatother

\definecolor{listingsbg}{HTML}{E7E7E7}
\definecolor{kwcolor}{HTML}{7F0055}
\definecolor{strcolor}{HTML}{2A00FF}
\definecolor{cocolor}{HTML}{3F7F5F}

\lstset{tabsize=4, basicstyle=\sffamily\small, keywordstyle=\bfseries\color{kwcolor}, commentstyle=\color{cocolor},
stringstyle=\color{strcolor}, columns=[r]fullflexible, escapechar={�}, frame=single, %framexleftmargin=-5pt, framexrightmargin=-5pt, 
xleftmargin=5pt, xrightmargin=5pt, rulecolor=\color{lightgray}, showstringspaces=false, backgroundcolor=\color{listingsbg!70}}

\newlength{\XdocItemIndent}
\newlength{\XdocTEffectiveWidth}

\lstdefinelanguage{Config}
  {morekeywords={dummy},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }
\lstdefinelanguage{Java}
  {morekeywords={abstract, continue, for, new, switch, assert, default, package, synchronized, boolean, do, if, private, this, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, transient, catch, extends, int, short, try, char, final, interface, static, void, class, finally, long, strictfp, volatile, float, native, super, while},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }
\lstdefinelanguage{Franca}
  {morekeywords={package, import, model, from, typeCollection, interface, version, major, minor, attribute, method, broadcast, in, out, error, readonly, noSubscriptions, fireAndForget, selective, manages, array, of, struct, union, typedef, is, map, to, enumeration, extends, polymorphic, Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Boolean, String, Float, Double, ByteBuffer, contract, PSM, vars, state, transition, initial, call, respond, signal, set, update},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }
\lstdefinelanguage{FDeploy}
  {morekeywords={import, specification, extends, for, optional, default, providers, instances, interfaces, type_collections, attributes, methods, broadcasts, arguments, structs, struct_fields, unions, union_fields, arrays, enumerations, enumerators, strings, numbers, integers, floats, Boolean, Integer, String, Interface, define, provider, instance, interface, attribute, method, broadcast, in, out, array, struct, enumeration, false, true},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }
\lstdefinelanguage{Xtend}
  {morekeywords={abstract, continue, def, override, for, new, switch, assert, default, goto, package, synchronized, boolean, do, if, private, this, it, break, double, implements, protected, throw, byte, else, import, public, throws, case, enum, instanceof, return, catch, extends, int, short, try, char, final, static, void, class, finally, long, float, super, while, create, dispatch, extension, typeof, as, val, var, true, false, null, IF, ELSE, ELSEIF, ENDIF, FOR, ENDFOR, BEFORE, AFTER, SEPARATOR},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

\usepackage{hyperref}

\author{Release 0.3.1-SNAPSHOT}

\titlepic{\includegraphics{images/FrancaLogo120.png}}

\title{Franca User Guide}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
\label{Introduction}
Welcome to \textit{Franca}! \textit{Franca} is a framework for definition and transformation of
software APIs. The core of it is \textit{Franca IDL} (Interface Definition Language),
which is \hyperref[FrancaIDL]{a textual language for specification of APIs~(�\ref*{FrancaIDL})}.
As Franca is based on Eclipse, there are some \hyperref[Intro_FrancaTools]{powerful tools~(�\ref*{Intro_FrancaTools})}
which can be used to work with Franca. E.g., a user-friendly editor for
Franca IDL files is available.

\section{Copyright / License}
\label{Intro_FrancaLicense}

\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-4.0\tabcolsep}
\noindent\begin{tabular}{p{0.67\XdocTEffectiveWidth}p{0.33\XdocTEffectiveWidth}}
\toprule
Copyright (c) 2013 itemis AG
		
			(\href{http://www.itemis.de}{http://www.itemis.de}).
			
			All rights reserved.

 & Updates and new features.

\\
\midrule
Copyright (c) 2012 Harman International
		
			(\href{http://www.harman.com}{http://www.harman.com}).
			
			All rights reserved.

 & Initial version.

\\
\bottomrule
\end{tabular}

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
This document and the accompanying software/materials
		are made available under the terms of the Eclipse Public License v1.0
		which accompanies this distribution, and is available at
		\href{http://www.eclipse.org/legal/epl-v10.html}{http://www.eclipse.org/legal/epl-v10.html}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
The information contained herein is subject to change without notice
		and is not warranted to be error-free. If you find any errors, please report
		them to us in writing.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
This software is developed for general use in a variety of information management
		applications. It is not developed or intended for use in any inherently dangerous
		applications, including applications which may create a risk of personal injury.
		If you use this software in dangerous applications, then you shall be responsible
		to take all appropriate fail-safe, backup, redundancy, and other measures to ensure
		the safe use of this software. Harman International and its affiliates disclaim
		any liability for any damages caused by use of this software in dangerous applications.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\section{Franca framework architecture}
\label{Intro_FrancaArchitecture}
Especially for system integrators, it is time and again necessary to combine
software components or subsystems which use different kinds of 
inter-process-communication (IPC) and different IDLs. Possible reasons for this
are:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
the need for integration of 3rd-party and legacy components

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
conformance to new standards and

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
non-functional system requirements like performance and footprint

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

This integration is often solved by ad-hoc solutions, developing wrappers 
or adapters manually after defining a mapping of two IDLs' concepts which
should be integrated. This approach is tedious and often leads to inaccuracies 
and software shortcomings and bugs in the runtime system.

Franca provides a framework for bridging the gap between different
IDLs by formally well-founded model transformations in an easy way.
Using the Franca framework, these transformations will be encapsulated
as \textit{Franca connectors}, which are Eclipse plugins for loading/saving of
IDL model instances (i.e. files which formally describe interfaces) and
converting them to or from Franca IDL files. Franca (the \textit{lingua franca})
is the pivot point for these transformations.
\autoref{TransformationFramework} shows how connectors (depicted by arrows)
form a star-shaped network between Franca IDL and other IDLs. 

\begin{figure}[!ht]
\centering
\includegraphics[width=0.50\textwidth]{images-gen/franca_trafos_conceptual_hts_logical.png}
\caption{Franca transformation framework.}
\label{TransformationFramework}
\end{figure}

Advanced features like model validation can also be included in the connector plugins.
Franca provides its own extensive model validation, which can be used as an
intermediate validation step while transforming models from one IDL to another.

Additionally, the Franca framework is well-suited for developing 
code generators. This is shown in \autoref{GenerationFramework}.
Using connectors (i.e., IDL model transformations) and
generators together leads to powerful tool sets which can be used to 
convert interfaces in several IDLs to Franca and generate source code and
configuration files from this. Thus, Franca really helps to solve the 
integration problem mentioned above in an elegant way.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.70\textwidth]{images-gen/franca_generators_conceptual_hts_logical.png}
\caption{Franca transformation and generation framework.}
\label{GenerationFramework}
\end{figure}

For detail information about the architecture concepts of Franca,
please refer to chapter \hyperref[FrancaConcepts]{Franca Concepts~(�\ref*{FrancaConcepts})}.

\section{Franca IDL}
\label{Intro_FrancaIDL}
Franca IDL is language-neutral and also independent of concrete bindings.
Here is a simple example with an interface which supports just one method:


\begin{lstlisting}[language=Franca]
interface CalculatorAPI {
	method add {
		in {
			Float a
			Float b
		}
		out {
			Float sum
		}
	}
}
\end{lstlisting}

APIs defined with Franca IDL may consist of attributes, methods and broadcasts.
You may rely on built-in, primitive types (e.g., Int16 or String) or define your
own types using arrays, structures, enumerations, type aliases, maps and others.
For some of the types, inheritance is supported.

Franca IDL also supports to optionally define the \textit{dynamic behaviour} of an API.
This is done by specifying a \textit{contract}, which basically consists of a 
\textit{protocol state machine} (PSM) which is a part of the interface.
The contract defines states of the interface and transitions between those states.
Each transition is triggered by a method call, a broadcast, or the change of an
attribute of the interface. For client/server-like architectures, you can think of
the PSM as being part of the connection.      

Franca IDL specifications may be distributed to multiple files.
This is especially useful if several APIs have to be defined, which share some
common data types and structures. 

For detail information about syntax and semantics of Franca IDL, please
refer to the \hyperref[FrancaIDL]{Franca IDL Language Reference~(�\ref*{FrancaIDL})}.

\section{Franca Tooling}
\label{Intro_FrancaTools}
The core tool for Franca users is the nice textual editor which can be used
to review and edit Franca IDL files. The editor is provided as Eclipse plugin
and can be installed in any Eclipse environment which provides modeling support.
\autoref{FrancaEditorScreenshot} shows a screenshot of Franca's IDL editor in action.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{images/franca_editor_screenshot_1.png}
\caption{Screenshot of Franca IDL editor.}
\label{FrancaEditorScreenshot}
\end{figure}

The editor provides syntax highlighting,
code completion, folding, online validation, a helpful outline view,
jump-to-definition and find-references with shortcuts, and many more features.
You can find additional information about the editor \hyperref[FrancaTooling]{here~(�\ref*{FrancaTooling})}.

The Franca distribution also contains an example generator, which produces
HTML files from Franca IDL files. This can be used as is (for generating 
HTML documentation from interface definitions), or adapted to your needs by
using the clone-and-own pattern. 

For more information about the Franca IDL editor and other tooling,
please refer to chapter \hyperref[FrancaTooling]{Franca Tooling~(�\ref*{FrancaTooling})}.


\chapter{Getting Started}
\label{GettingStarted}
All tooling needed for Franca is available as a set of Eclipse plug-ins.
Thus, the easiest way to start with Franca is to use an off-the-shelf Eclipse
distribution and add those plug-ins and their dependencies to this environment.
This section will describe how to quickly install this tool platform and be able to 
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
define interfaces using the Franca IDL textual editor

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
develop a code generator based on Franca IDL interfaces

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

If you haven't done so, we recommend that you read the \hyperref[Introduction]{Introduction chapter~(�\ref*{Introduction})}
now in order to get some fundamental information about Franca.

\section{Install Eclipse-based Franca tooling}
\label{GettingStarted_InstallBinary}
The installation instructions for the Franca tooling are not part of this 
User Guide. You will find them online at the Franca EclipseLabs page (Wiki section):
\href{http://code.google.com/a/eclipselabs.org/p/franca/wiki/FrancaQuickInstallGuide}{Franca Quick Install
Guide}.

\section{Import example project}
\label{GettingStarted_ImportExampleProject}
The example project \textit{org.franca.examples.basic} is provided as part of
Franca's public distribution. Put this project onto your local file system and 
import it to the Eclipse workspace by the following steps:
\setlength{\XdocItemIndent}{\textwidth}
\begin{enumerate}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
In Eclipse, select \textit{File > Import...}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
In the dialog that opens up, select \textit{General > Existing projects into workspace}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
In the \textit{Import projects} dialog, browse the file system and locate the 
	     directory where the \textit{org.franca.examples.basic} directory is contained.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Select the project in the \textit{Projects} list.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Ensure that \textit{Copy projects into workspace} is not selected.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Press \textit{Finish}.

\end{minipage}
\end{enumerate}
\addtolength{\XdocItemIndent}{2.5em}

The example project will be part of your Eclipse workspace now.
Open the Franca IDL example file \textit{examples/franca/demo1.fidl} by locating it
in the Package Explorer and double-click it.
The Franca IDL textual editor will open, allowing you to review the example 
and also do some changes.   

\section{Contents of example project}
\label{GettingStarted_ExampleProject}
The example project provides several test cases, which are located in the package
\textit{org.franca.examples.basic.tests}. You will find this package in the \textit{src} folder
which is part of the \textit{org.franca.examples.basic} example project.

Each of these test cases might be started by selecting \textit{Run As > JUnit Test} in the
test's context menu.

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
Test case \textit{Franca2HtmlTest.java}:
		This test loads a Franca example file and generates a documentation html page from it.
		The html page will be located in the folder \textit{src-gen/interfaces}.
		Press F5 for refreshing this folder in case it doesn't show up there after running
		the test case.  

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Test case \textit{HppGeneratorTest.java}:
		This test loads a Franca example file and generates a C++ class definition
		from it. The generated code will be printed on the console. It is just an
		example and is by far not complete.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\section{Create new Franca interface}
\label{GettingStarted_CreateNewInterface}
In order to create a new Franca interface, open the context menu of the
folder \textit{examples/franca} and select \textit{New > File}. In the \textit{New File} dialog,
enter a file name with the extension \textit{.fidl}. After pressing the \textit{Finish} button
the Franca IDL editor will show up with the new file, which is still empty.

Now you may use keyboard shortcuts like Ctrl-Space to use Content Assist to create
the contents for your Franca file. 

More information is available about \hyperref[FrancaConcepts]{Franca concepts~(�\ref*{FrancaConcepts})}
and in the Franca \hyperref[FrancaIDL]{language reference~(�\ref*{FrancaIDL})}.

\section{Develop your own code generator}
\label{GettingStarted_DevelopCodegenerator}
If you want to develop a new generator which can produce source code from any 
Franca IDL file, we recommend to use the example generator from test case
\textit{HppGeneratorTest.java}. This code generator has been developed with the 
Xtend language, which translates directly to Java classes.
Further documentation about Xtend can be found \href{http://www.xtend-lang.org}{here}.

The example generator \textit{ExampleHppGenerator.xtend} is located in folder \textit{src},
in package

\textit{org.franca.examples.basic.generators}.

For starting quickly, clone this xtend file and also the corresponding test case
and adapt the copied files for your needs.
For more information on generator development, please refer to
\hyperref[BuildingGenerators]{Building generators with Franca~(�\ref*{BuildingGenerators})}.


\chapter{Franca Concepts}
\label{FrancaConcepts}
The Franca framework is built on several concepts:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
the Franca core model and the Franca IDL

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
the Franca transformation framework

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
the Franca generator framework

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
distinction of IDL model and deployment model

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

This chapter provides some detailed explanation for each of these concepts.

\section{Franca Core Model and IDL}
\label{FrancaConcepts_IDL_CoreModel}
\subsection{Franca Core Model}
\label{FrancaConcepts_IDL_CoreModel_Basic}
Franca aims at formal definitions of software interfaces. Basically, this targets
information about attributes and methods provided by the interfaces which should
be defined. Franca contains a \textit{core model}, which describes these concepts
(and some more, like datatypes). The core model is implemented using the
\href{http://www.eclipse.org/modeling/emf/}{Eclipse Modeling Framework (EMF)}.
Based on the EMF technology, there is a rich set of tools available
for manipulating and transforming models describing software interfaces.

The detailed API of Franca's core model is described
in section \hyperref[FrancaModelAPI]{Franca Model API~(�\ref*{FrancaModelAPI})}.

\subsection{Franca IDL Model}
\label{FrancaConcepts_IDL_CoreModel_IDL}
Franca is not only able to define interfaces \textit{somehow}, but via an IDL.
Therefore, Franca IDL has been created as a textual language (a \textit{DSL}, short
for Domain-Specific Language), which can be used with the help of a nice editor 
to create, review and edit software interfaces. The internal representation 
of Franca IDL files (i.e. interface definitions) is the core model described above.
The IDL is implemented with \href{http://www.eclipse.org/xtext}{Xtext}.

The detailed reference of Franca IDL is described \hyperref[FrancaIDL]{here~(�\ref*{FrancaIDL})}.

\subsection{Franca Core Eclipse Plugins}
\label{FrancaConcepts_IDL_CoreModel_Plugins}
The following plugins are relevant for the core model and the IDL:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{org.franca.core}: This plugin contains the core model based on EMF.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{org.franca.core.dsl}: This plugin contains the IDL definition.
		It is based on \textit{org.franca.core} and Xtext.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{org.franca.core.dsl.ui}: This plugin contains the IDL textual editor.
		It is based on \textit{org.franca.core}, \textit{org.franca.core.dsl}, Xtext and
		the user interface parts of the Eclipse IDE.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\section{Franca Transformation Framework}
\label{FrancaConcepts_IDL_Transformations}
Based on the Franca core model described above, interface specifications
defined in other IDLs (in many different formats, ranging from XML to textual DSLs
or proprietary formats) can be transformed to/from Franca.
In that context, Franca plays the role of a pivot model. Different IDLs can be 
transformed into each other by chaining transformations like: \textit{IDL1 to Franca to IDL2}.

\autoref{FrancaExampleNetwork} shows an example setup of Franca transformations and generators.
The green arrows indicate transformation and reverse transformation between the
Franca core model and another IDL's model. 

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{images/franca_architecture.png}
\caption{An example setup of Franca transformations and generators.}
\label{FrancaExampleNetwork}
\end{figure}

Generally, IDLs in arbitrary formats can be part of the transformation framework.
However, Franca provides special support for IDLs which are implemented using EMF.
In this case, the \href{http://www.xtend-lang.org}{Xtend} language can be used to
implement transformations in an elegant way.

Franca defines a \textit{pattern} for implementing such transformations: the \textit{connector}.
A Franca connector for a specific non-Franca IDL provides functions for loading
and saving models in that IDL and also for transforming models to/from Franca.
Each connector should implement Franca's \textit{IFrancaConnector} interface located in the
\textit{org.franca.core.framework} package. Typically, each connector is provided as a
separate Eclipse plugin, e.g. \textit{org.franca.connectors.dbus} for handling 
DBus Introspection XML files. 

See chapter \hyperref[BuildingTransformations]{Bulding Transformations~(�\ref*{BuildingTransformations})} for more details 
on this concept. In chapter \hyperref[FrancaConnectors]{Franca Connectors~(�\ref*{FrancaConnectors})} the currently
supported connectors are listed and explained in some more detail.

\section{Franca Generator Framework}
\label{FrancaConcepts_IDL_Generators}
The Franca core model is also used as a starting point for generating code and
other artifacts. As EMF provides a generated \hyperref[FrancaModelAPI]{Java API~(�\ref*{FrancaModelAPI})}
out of Franca's core model, a plethora of tools can be used for building
generators. We recommend to use the \href{http://www.xtend-lang.org}{Xtend}
language for this, as it is a simple and productive way of implementing
generators based on a Java API.

In Franca' source distribution you can find the
\hyperref[FrancaTooling_Generators]{HTML Generator~(�\ref*{FrancaTooling_Generators})}, which generates nice HTML pages
out of Franca IDL interfaces. This generator can serve as an example of how
to build generators for Franca models with Xtend. 

See chapter \hyperref[BuildingGenerators]{Building Generators~(�\ref*{BuildingGenerators})} for more details 
on this concept. 

\section{Franca Deployment Models}
\label{FrancaConcepts_DeploymentModels}
The contents of the Franca core model and the IDL are deliberately restricted to
the actual interface specification. Additionally, there is a lot of information
regarding to interfaces and APIs which are related to the implementation
of the interfaces on a target platform and the actual deployment of these
interfaces on the platform. Some examples for this kind of data:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
How are the data types encoded on the target platform (e.g., endianness, padding)?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Are calls blocking or non-blocking?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
How can the instances of an interface be found and addressed (i.e., service discovery)?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Which quality-of-service promises are valid?

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

The next \hyperref[FrancaConcepts_AddingFeatures]{section~(�\ref*{FrancaConcepts_AddingFeatures})} provides some guidelines
for deciding whether new features belong to the Franca IDL itself or to the deployment model.

The actual information in a deployment model depends heavily on the target IPC framework.
Therefore, there is no generic deployment model (on a similar abstraction level as Franca IDL itself).
Instead, the features of the actual deployment model for the target platform can only
be defined with the target platform in mind.

As the information which must be stored in a deployment model is equally important
as soon as a Franca IDL interface is incarnated on a real target, the Franca Framework
provides support for defining and creating deployment models.
A separate Franca Deployment Language is available, which contains of two parts:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
specification of deployment properties (done only once per deployment target platform)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
definition of actual values for deployment properties (done for every Franca interface
		which has to be deployed on the target platform)

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

As it is important that deployment properties can be accessed easily during code generation,
validation, etc., Franca provides some infrastructure for retrieving the deployment data
attached to various interface entities easily.

See chapter \hyperref[DeploymentModels]{Franca Deployment Models~(�\ref*{DeploymentModels})} for more details 
about deployment concepts, their relation to Franca IDL and some examples.

\section{Guidelines for adding new features to Franca IDL}
\label{FrancaConcepts_AddingFeatures}
Although the feature set of Franca IDL can cover the needs of many today's IDLs
and IPC frameworks on the market, there might be the need to extend Franca IDL.
Technically, this is no big deal. However, extending the expressivity of Franca IDL
will usually require adaptions on existing transformations and code generators
in order to reflect the IDL changes in the dependent artifacts. Thus, every extension
to Franca IDL should be well-founded and backed with a solid semantic notion. 

In order to support features which are seemingly missing in Franca IDL,
there are several options:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
actually extend Franca IDL to support the feature

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
put the additional information in a \hyperref[FIDL_CommentsStructured]{structured comment~(�\ref*{FIDL_CommentsStructured})}
	     (using an appropriate @-tag)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
put the additional information into a
	     platform-specific \hyperref[FrancaConcepts_DeploymentModels]{deployment model~(�\ref*{FrancaConcepts_DeploymentModels})}

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
deliberately ignore the feature (if there is a good reason for this)

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

In order to decide which of these option is appropriate consider the following criteria:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{IDL}: information needed only for the application logic like:
		\setlength{\XdocItemIndent}{\textwidth}
\begin{enumerate}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
syntactic description of interfaces

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
dynamic behaviour, e.g. application protocol contracts

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
application constraints:
				\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
like discrete values

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
interval ranges accepted for method input parameters

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
default values for attributes

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}


\end{minipage}
\end{enumerate}
\addtolength{\XdocItemIndent}{2.5em}


\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{deployment model}: information that is used for code generation but is
		highly dependent on the backend IPC used
		\setlength{\XdocItemIndent}{\textwidth}
\begin{enumerate}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
call semantic: synchronous, asynchronous?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
communication partner addressing information,
				e.g. TCP/IP addresses or service discovery related information

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
data coding: physical representation of data (e.g., alignment, memory layout)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
QoS information, allocation of ressources:
				network (bandwidth, priorities), CPU (priority, processing share),
				RAM (quota), etc.

\end{minipage}
\end{enumerate}
\addtolength{\XdocItemIndent}{2.5em}


\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{structured comments}: information not used for productive code generation
		\setlength{\XdocItemIndent}{\textwidth}
\begin{enumerate}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
documentation

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
meta-information used during transformations
				(e.g., URI or filename of source IDL

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
meta-information regarding the interface itself (e.g. deprecation)

\end{minipage}
\end{enumerate}
\addtolength{\XdocItemIndent}{2.5em}


\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}


\chapter{Franca IDL Reference}
\label{FrancaIDL}
The core of Franca IDL is the support for \hyperref[FIDL_Interface]{interface definitions~(�\ref*{FIDL_Interface})}, consisting of
attributes, methods and broadcasts. Those definitions will be based on a \hyperref[FIDL_Types]{type system~(�\ref*{FIDL_Types})},
which provides a variety of primitive and user-defined types. 
Additionally, the dynamic behavior of interfaces can be specified using \hyperref[FIDL_Contracts]{contracts~(�\ref*{FIDL_Contracts})}
consisting of protocol state machines.
Types can be defined either on a global scope using \hyperref[FIDL_TypeCollection]{type collections~(�\ref*{FIDL_TypeCollection})},
or as part of an \hyperref[FIDL_Interface]{interface definition~(�\ref*{FIDL_Interface})}.
Finally, Franca IDL supports Java-doc like tagged comments, called \hyperref[FIDL_Comments]{structured comments~(�\ref*{FIDL_Comments})}
and language features like \textit{packages} and \textit{imports} which can be used for defining interfaces using
\hyperref[FIDL_MultipleFiles]{multiple Franca IDL files~(�\ref*{FIDL_MultipleFiles})}.

\section{Data types}
\label{FIDL_Types}
Franca supports a predefined set of primitive data types and a variety of user-defined types.
User-defined types may be arrays, type aliases, structures, unions, enumerations or maps.
User-defined types can refer to primitive types or other, previously defined types. 

\subsection{Primitive types}
\label{FIDL_PrimitiveTypes}
The primitive types supported by Franca are listed in \autoref{PrimitiveTypes}.
There is a number of very specific signed and unsigned integer types with varying ranges.
This allows to be very specific about the size of these types on any target platform.
In a future version of Franca IDL it will be possible to specify integer types by
their specific range (min/max). The actual representation will then be computed 
by a configurable type engine.


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-4.0\tabcolsep}
\noindent\begin{tabular}{p{0.13\XdocTEffectiveWidth}p{0.88\XdocTEffectiveWidth}}
\toprule
\textit{Type name}

 & \textit{Description}

\\
\midrule
\protect\lstinline[language=Franca]�UInt8�

 & unsigned 8-bit integer (range 0..255)

\\
\protect\lstinline[language=Franca]�Int8�

 & signed 8-bit integer (range -128..127)

\\
\protect\lstinline[language=Franca]�UInt16�

 & unsigned 16-bit integer (range 0..65535)

\\
\protect\lstinline[language=Franca]�Int16�

 & signed 16-bit integer (range -32768..32767)

\\
\protect\lstinline[language=Franca]�UInt32�

 & unsigned 32-bit integer (range 0..4294967295)

\\
\protect\lstinline[language=Franca]�Int32�

 & signed 32-bit integer (range -2147483648..2147483647)

\\
\protect\lstinline[language=Franca]�UInt64�

 & unsigned 64-bit integer

\\
\protect\lstinline[language=Franca]�Int64�

 & signed 64-bit integer

\\
\protect\lstinline[language=Franca]�Boolean�

 & boolean value, which can take one of two values: false or true.

\\
\protect\lstinline[language=Franca]�Float�

 & floating point number (4 bytes, range +/- 3.4e +/- 38, \textasciitilde{}7 digits)

\\
\protect\lstinline[language=Franca]�Double�

 & double precision floating point number (8 bytes, range +/- 1.7e +/- 308, \textasciitilde{}15 digits)

\\
\protect\lstinline[language=Franca]�String�

 & character string, see caveat below

\\
\protect\lstinline[language=Franca]�ByteBuffer�

 & buffer of bytes (aka BLOB), see caveat below

\\
\bottomrule
\end{tabular}
\caption{Primitive types of Franca IDL.}
\label{PrimitiveTypes}
\end{table}

Caveat: APIs should use arguments of type \protect\lstinline[language=Franca]{String} or
\protect\lstinline[language=Franca]{ByteBuffer} only for transporting payload data which is
not parsed by the server component which offers the interface.
A useful example for \protect\lstinline[language=Franca]{ByteBuffer} arguments is a 
protocol layer which examines the header of an incoming data
package, but doesn't look at the payload data.
If the server does \textit{deep packet inspection} or similar on the
incoming data, the argument is used as a tunnel for a protocol
which is not specified by the API. This bypass of the API definition
weakens the API abstraction and will inevitably lead to integration
issues and runtime problems.

The actual physical encoding of the primitive types depends on the target language.
A default encoding will be defined as part of Franca's deployment model. 
Exceptions from this default encoding can be defined in the target-language-specific
deployment model.

\subsection{Arrays}
\label{FIDL_Types_Array}
There are two ways of defining array types: explicitly named arrays or implicit
array types without a name.

Explicitly named, one-dimensional arrays can be defined by 
\protect\lstinline[language=Franca]{array ExampleArray of UInt8} 

The array's element type can be any primitive or user-defined type, including another array.
This can be used to define multi-dimensional arrays:

\begin{lstlisting}[language=Franca]
array ExampleArrayRow of UInt8
array ExampleArray of ExampleArrayRow
\end{lstlisting}

Implicit ("inline") array types are defined by attaching square brackets (e.g., \protect\lstinline[language=Franca]{UInt8[]})
to any other type definition. This can be done for attributes, struct members and
arguments of methods and broadcasts. See more examples below. Note: Inline arrays can only be defined
one-dimensional. If multi-dimensional arrays are needed, only one dimension can be defined as unnamed
array. 

The syntax for defining implicit array types doesn't support specifying fixed array sizes or
array size limits. If you want to define such properties for arrays, you might use Franca's
\hyperref[FrancaConcepts_DeploymentModels]{deployment model~(�\ref*{FrancaConcepts_DeploymentModels})} feature.

\subsection{Enumerations}
\label{FIDL_Types_Enum}
\subsubsection{Basic enumerations}
\label{FIDL_Types_Enum_Basic}
Enumerations can be defined by

\begin{lstlisting}[language=Franca]
enumeration ExampleEnumeration {
	VALUE_1
	VALUE_2
	VALUE_3
	// ...
}
\end{lstlisting}

Values for the enumeration identifiers can be defined optionally.
They are defined as string constants which usually will contain an integer number:

\begin{lstlisting}[language=Franca]
enumeration ExampleEnumeration {
	VALUE_1 = "10"
	VALUE_2 = "20"
	VALUE_3 = "30"
	// ...
}
\end{lstlisting}

\subsubsection{Enumeration inheritance}
\label{FIDL_Types_Enum_Inheritance}
Enumeration types support \textit{inheritance} by using the keyword \textit{extends}.
This allows to derive a new enumeration type from an existing one and add
further enumerators to the base enumeration. Only single inheritance is allowed for
each enumeration - however, a chain or tree of enumerations can be build. Example:

\begin{lstlisting}[language=Franca]
enumeration BaseEnumeration {
	VALUE_1
	VALUE_2
}

enumeration DerivedEnumeration extends BaseEnumeration {
	VALUE_3
	VALUE_4
}
\end{lstlisting}

If the target language doesn't support inheritance for enumeration types, the \textit{extends}-chain
will be transformed into a flat enumeration consisting of all enumerators of the base type(s)
and those of the derived type.

\subsection{Structures}
\label{FIDL_Types_Struct}
A \textit{struct} (also called \textit{record}, \textit{tuple}, or \textit{compound data}) is a value that contains
other values, typically in fixed number and sequence and typically indexed by names.
The elements of structs are usually called \textit{fields} or \textit{members} (source: Wikipedia).

\subsubsection{Basic structs}
\label{FIDL_Types_Struct_Basic}
User-defined structures can be defined by specifying the structure's members, with a type
and name for each member: 

\begin{lstlisting}[language=Franca]
struct ExampleStruct {
	UInt8 member1
	String member2
	ExampleArray member3
	UInt16[] member4
}
\end{lstlisting}

Element types might be predefined types or user-defined types. This allows e.g. nested structures or
arrays of structures. Element types may also be arrays, e.g., \textit{member4} is an unnamed array of type
\protect\lstinline[language=Franca]{UInt16}. 

\subsubsection{Struct inheritance}
\label{FIDL_Types_Struct_Inheritance}
Struct types support \textit{inheritance} by using the keyword \textit{extends}.
This allows to derive a new structure type from an existing one and add
further structure members to the base's members. Only single inheritance is allowed for
each structure definition - however, a chain or tree of structures can be build. Example:

\begin{lstlisting}[language=Franca]
struct BaseStruct {
	UInt8 member1
	ExampleArray member2
}

struct DerivedStruct extends BaseStruct {
	ExampleArray member3
}
\end{lstlisting}

If the target language doesn't support inheritance for structure types, the \textit{extends}-chain
will be transformed into a flat structure consisting of all members of the base
type(s) and those of the derived type.

\subsubsection{Polymorphic structs}
\label{FIDL_Types_Struct_Polymorphic}
The root type in a struct inheritance hierarchy may be marked with the 
\textit{polymorphic}-keyword. Consider the following example:

\begin{lstlisting}[language=Franca]
method callme {
	in {
		BaseStruct t
	}
}

struct BaseStruct polymorphic {
	Int16 a
}

struct Derived1 extends BaseStruct {
	Int16 b
}
	
struct Derived2 extends BaseStruct {
	String c
}
\end{lstlisting}

The caller of method \textit{callme} might provide an argument of type \textit{Derived1},
although the method's argument type is declared as type \textit{BaseStruct}.
In an environment where polymorphism is fully supported, the server will then
be able to receive an object of the actual type, i.e., \textit{Derived1}.
It will be able to access the struct element \textit{b}.

However, as full polymorphism support usually requires some implementation
overhead in the IPC target platform, this behavior has to be explicitly switched
on by flagging the root of the struct inheritance hierarchy with the
keyword \textit{polymorphic}. Without setting the root struct type to \textit{polymorphic},
the server-side implementation of the interface will only be able to access the
actual type used in the interface definition (and not derived types). 
This low-footprint behavior is the default.

\subsection{Unions (aka variants)}
\label{FIDL_Types_Union}
A \textit{union} is a value that may have any of several representations or formats;
or a data structure that consists of a variable which may hold such a value (source: Wikipedia).

\subsubsection{Basic unions}
\label{FIDL_Types_Union_Basic}
Unions can be defined by specifying its possible value types, together with a name for
each representation. As a union will have only one representation at a time, the order of
the union's elements is not important. Example of a union definition: 

\begin{lstlisting}[language=Franca]
union ExampleUnion {
	UInt32 element1
	Float element2
}
\end{lstlisting}

Element types might be predefined types or user-defined types.
This allows e.g. nested unions, or unions of structures.
No two elements of an union may have the same type. 

\subsubsection{Union inheritance}
\label{FIDL_Types_Union_Inheritance}
Union types support \textit{inheritance} by using the keyword \textit{extends}.
This allows to derive a new union type from an existing one and add
further elements to the base union. Only single inheritance is allowed for
each union definition - however, a chain or tree of unions can be build. Example:

\begin{lstlisting}[language=Franca]
union BaseUnion {
	UInt32 genericRepresentation
}

union DerivedUnion extends BaseUnion {
	Float aFloat
	String aString
}
\end{lstlisting}

If the target language doesn't support inheritance for union types, the \textit{extends}-chain
will be transformed into a flat union consisting of all elements of the base
type(s) and those of the derived type.

\subsection{Maps (aka dictionaries)}
\label{FIDL_Types_Map}
Maps represent key/value-stores and are typically implemented by B-trees or hashes.
The definition for Maps with Franca IDL specifies the key type and the value type.
Example:

\begin{lstlisting}[language=Franca]
map ExampleMap {
	Int16 to ExampleStruct
}
\end{lstlisting}

Key types as well as value types might be primitive or user-defined types. 
NB: In some target languages, key types might be restricted to primitive types.

\subsection{Type definitions (aka aliases)}
\label{FIDL_Types_TypeDef}
Type definitions can be used to create new type names which are simple aliases for
existing primitive or user-defined types. Example:
\protect\lstinline[language=Franca]{typedef ExampleAlias is UInt32}

\section{TypeCollection definition}
\label{FIDL_TypeCollection}
A \textit{type collection} is a (maybe empty) set of user-defined types.
Previous to Franca-0.8.0, user-defined types could be located on the
top-level of a Franca model. This has been banned with Franca-0.8.0 in order to 
provide a consistent scheme of fully qualified names and versioning for
user-defined types.

Each type collection in Franca has some metadata: a mandatory fully qualified
\textit{name} for the collection and an optional \textit{version number} (with major/minor scheme).
The following example shows the basic type collection definition:


\begin{lstlisting}[language=Franca]
typeCollection ExampleTypeCollection {
	version { major 3 minor 1 }
	
	// put user-defined types here
}
\end{lstlisting}

As type collections are just a plain collection of user-defined types,
inheritance is not supported for them. All user-defined types inside a
type collection have global visibility. I.e., they can be used for
defining interfaces as well as user-defined types in another type collection.
This is different from the visibility of types that are defined as part of an
interface (see below).  

\section{Interface definition}
\label{FIDL_Interface}
Each interface in Franca consists of some metadata (e.g., interface name and version number),
the actual interface definition (consisting of attributes, methods and broadcasts), an optional
\hyperref[FIDL_Contracts]{contract~(�\ref*{FIDL_Contracts})} specifying the dynamic behavior of the interface and, last but not least,
user-defined \hyperref[FIDL_Types]{data types~(�\ref*{FIDL_Types})}. An interface definition might use the user-defined
types of another interface definition only if it inherits (directly or indirectly)
from that interface definition. Thus, the visibility of user-defined types as part of an
interface definition is restricted. This is different from the global visibility of types
which are part of a type collection.    

\subsection{Basic interface definition}
\label{FIDL_Interface_Basic}
\subsubsection{Interface name, version and contents}
\label{FIDL_Interface_Basic_Structure}
The basic interface definition using Franca includes an interface name and a version number (major/minor
scheme):

\begin{lstlisting}[language=Franca]
interface ExampleInterface {
	version { major 5 minor 0 }
	
	// put attributes here
	// put methods here
	// put broadcasts here
	
	// put optional contract here
	
	// put type definitions here
}
\end{lstlisting}

The order of the elements of an interface has been chosen deliberately and cannot be changed.

The name of an interface has to be a fully qualified name, i.e., a list of segments which are
separated by dots. The fully qualified name thus defines a path which is to be interpreted
relatively to the package name specified at the beginning of each Franca file. Example:

\begin{lstlisting}[language=Franca]
interface examples.franca.ExampleInterface {
	// ...
}
\end{lstlisting}

\subsubsection{Interface versioning and change compatibility}
\label{FIDL_Interface_Basic_Versioning}
The specification of a major/minor version number is optional, but is strongly recommended.
Changes in the major number indicate changes which are not backward compatible.
Example use cases for \textit{incompatible} changes:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
remove attribute, method or broadcast

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
remove element from struct or union

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
rename an attribute

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
rename a method or broadcast, or one of its arguments

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
rename a user-defined data-type

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
add a contract to an interface which previously didn't have any

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
tighten the constrains for the dynamic behavior of an interface (i.e., its contract)

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

Interface designers should try hard to avoid incompatible changes, or at least provide
periods during which a feature is marked as deprecated before it is removed completely. 

Changes in the minor number indicate changes which are backward compatible.
Example use cases for backward \textit{compatible} changes:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
add attribute, method or broadcast

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
add an argument for a method or broadcast (*)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
add a parameter for a struct or union (*)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
remove a contract from an interface

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
ease restrictions on the dynamic behavior of an interface (i.e., its contract)

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

(*) In some target IDLs, adding arguments for methods or broadcast or adding members to
structs might be regarded as incompatible change. It might be hard to map the version numbers
between Franca and those IDLs.

\subsubsection{Interface inheritance}
\label{FIDL_Interface_Basic_Inheritance}
Franca supports interface \textit{inheritance} by using the keyword \textit{extends}.
This allows to derive a new interface from an existing one and add
further elements to the base's members. Only single inheritance is allowed for
each interface definition - however, a chain or tree of interfaces can be build. Example:

\begin{lstlisting}[language=Franca]
interface BaseInterface {
	// ...
}

interface DerivedInterface extends BaseInterface {
	// ...
}
\end{lstlisting}

\autoref{InheritanceSemantics} lists all interface members and
how their semantics is handled with respect to interface inheritance.


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-4.0\tabcolsep}
\noindent\begin{tabular}{p{0.20\XdocTEffectiveWidth}p{0.80\XdocTEffectiveWidth}}
\toprule
\textit{Interface element}

 & \textit{Inheritance semantics}

\\
\midrule
attributes

 & All attributes of the base interface are inherited by the derived interface.
		   Overloading of attributes is not allowed (i.e., attribute with same name in 
		   base and derived interface).

\\
methods

 & All methods of the base interface are inherited by the derived interface.
		   Overloading of methods is not allowed (i.e., method with same name in 
		   base and derived interface). This might change in a future release of Franca.
		   It is not possible for a derived interface to add a parameter to a method
		   of its base interface. 

\\
broadcasts

 & All broadcasts of the base interface are inherited by the derived interface.
		   Overloading of broadcasts is not allowed (i.e., broadcast with same name in 
		   base and derived interface). This might change in a future release of Franca.
		   It is not possible for a derived interface to add a parameter to a broadcast
		   of its base interface. 

\\
contract

 & The contract of the base interface is inherited by the derived interface.
		   It is not possible currently to redefine the inherited contract.
		   This will change in a future release of Franca (this will allow extending
		   the contract of its base interface by the derived interface).

\\
type definitions

 & All types of the base interface are inherited by the derived interface.
		   Redefining of types is not allowed (i.e., type with same name in 
		   base and derived interface).

\\
\bottomrule
\end{tabular}
\caption{Franca interface members and their semantics with respect to interface inheritance.}
\label{InheritanceSemantics}
\end{table}

If the target language doesn't support inheritance for interfaces, the \textit{extends}-chain
will be transformed into a flat interface definition consisting of all elements of the base
interface(s) and those of the derived interface.

\subsection{Attributes}
\label{FIDL_Interface_Attribute}
An \textit{attribute} is a property on the provider side, which is defined as part of the interface
with its type and name:


\begin{lstlisting}[language=Franca]
interface ExampleInterface {
	attribute UInt32 someAttribute
	attribute ExampleArray otherAttribute
	attribute String[] arrayAttribute
}
\end{lstlisting}

Attributes might have primitive types or user-defined types. They also can be defined
as inline, unnamed arrays (e.g., the attribute \textit{arrayAttribute} in the example above). 

The interface provider holds the data for its attributes and is able to change their values.
The clients of an interface might actively read its attributes' values.
The clients also might register for updates of this attribute and will get change
notifications afterwards. The detailed behavior of an attribute can be specified
by a combination of flags (see details below). 

For target IPC platforms which do not support attributes, code might be generated to add
this support. Typically, a getAttribute method and a registerForUpdate method would be provided.

\subsubsection{Readonly attributes}
\label{FIDL_Interface_Attribute_Readonly}
By default, clients can read and write the values of attributes. This access can
be restricted by specifying the per-attribute flag \textit{readonly}. When the flag is given,
the clients of the corresponding interface are not allowed to change the attribute's
value. However, the server might offer some methods which will change the attribute.
Example for the \textit{readonly}-flag:


\begin{lstlisting}[language=Franca]
interface ExampleInterface {
	attribute Float throttle
	attribute Float speed readonly
}
\end{lstlisting}

  
In the example, attribute \textit{throttle} can be written, while attribute \textit{speed} can only
by read by the clients.

\subsubsection{Client subscriptions}
\label{FIDL_Interface_Attribute_NoSubscriptions}
As mentioned above, clients of an interface might register for updates of
an attribute's value. Sometimes it is necessary to specify attributes which do not
support this subscription option. This can be accomplished by adding the
flag \textit{noSubscriptions} to the attribute's definition.
Example for the \textit{noSubscriptions}-flag:


\begin{lstlisting}[language=Franca]
interface ExampleInterface {
	attribute Double temperature readonly noSubscriptions
	attribute Boolean overheated
}
\end{lstlisting}

The attribute \textit{temperature} in the example will change often, so that it is better
to disallow subscriptions and use some kind of polling instead. For the boolean
attribute \textit{overheated}, subscriptions are possible (which is really what clients
expect). Note that the \textit{noSubscriptions} flag has been combined with the flag
\textit{readonly} in order to disallow changes by the clients, too. 

\subsection{Methods}
\label{FIDL_Interface_Method}
\subsubsection{Basic method syntax}
\label{FIDL_Interface_Method_Basic}
A \textit{method} in a Franca interface is called by one of the clients using the interface;
the response will be sent by the server. Therefore, a method definition will contain 
a set of \textit{in}-arguments and a set of \textit{out}-arguments, each with own type and name.
Example:


\begin{lstlisting}[language=Franca]
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}	
	}
}
\end{lstlisting}

Arguments might have primitive types or user-defined types. Arguments may be also 
specified as unnamed, inline arrays as in the following example:


\begin{lstlisting}[language=Franca]
interface LetterCount {
	method count {
		in {
			String[] words
		}
		out {
			UInt16[] counts
		}	
	}
}
\end{lstlisting}

The runtime behavior of a method call (e.g., blocking vs. non-blocking) is subject to
implementation by the underlying target IPC stack. Thus, it will not be specified as part
of the interface definition in the IDL. This information will be stored in an additional
\hyperref[FrancaConcepts_DeploymentModels]{deployment model~(�\ref*{FrancaConcepts_DeploymentModels})}, instead. 

\subsubsection{Declaration of method errors}
\label{FIDL_Interface_Method_Errors}
If a problem occurs during execution of the method on server side, the server
might issue an \textit{error} instead of sending the normal reply with its \textit{out}-arguments.
This semantics can be defined as in the following example:


\begin{lstlisting}[language=Franca]
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}
		error {
			DIVISION_BY_ZERO
			OVERFLOW
			UNDERFLOW
		}
	}
}
\end{lstlisting}

The component providing the \textit{Calculator} interface will either return a reply
with the \textit{out}-arguments or reply with an error code as specified by the 
nameless enumeration defined as part of the method specification.

In fact, the syntax above is the same as with the definition of
\hyperref[FIDL_Types_Enum]{enumerations~(�\ref*{FIDL_Types_Enum})}. I.e., optional values and structured comments
can be added to each of the enumerators. Moreover, a reference to a base enumerator
can be added using the keyword \textit{extends} - this allows inheriting of common
error codes:  


\begin{lstlisting}[language=Franca]
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}
		error extends GenericErrors {
			DIVISION_BY_ZERO
			OVERFLOW
			UNDERFLOW
		}			
	}

	enumeration GenericErrors {
		INVALID_PARAMATERS
		// ...
	}
}
\end{lstlisting}

Finally, it is possible to directly reference a separately defined \textit{enumeration},
which might also be located in a different Franca file. Example:


\begin{lstlisting}[language=Franca]
interface Calculator {
	method divide {
		in {
			UInt32 dividend
			UInt32 divisor
		}
		out {
			UInt32 quotient
			UInt32 remainder
		}
		error CalcErrors
	}

	enumeration CalcErrors {
		DIVISION_BY_ZERO
		OVERFLOW
		UNDERFLOW
	}
}
\end{lstlisting}

\subsubsection{Fire-and-forget methods}
\label{FIDL_Interface_Method_FireAndForget}
If neither \textit{out} arguments nor \textit{error} return codes are specified for
a method, the server will by default send an (empty) reply to its client.
This behavior can be changed by specifying a \textit{fireAndForget} flag for
the method, which indicates that the server will not respond at all.

Example:

\begin{lstlisting}[language=Franca]
interface Watchdog {
	method stillAlive fireAndForget {
		in { UInt16 health }
	}
}
\end{lstlisting}

This can be used to implement lightweight communication patterns.

\subsection{Broadcasts}
\label{FIDL_Interface_Broadcast}
A \textit{broadcast} in a Franca interface is called by the server and will be received
by the clients using the interface. A broadcast definition will contain a set of
\textit{out}-arguments, each with own type and name.
Example:


\begin{lstlisting}[language=Franca]
interface ExampleInterface {
	broadcast buttonClicked {
		out {
			ButtonId id
			Boolean isLongPress
		}
	}
}
\end{lstlisting}

Arguments might have primitive types or user-defined types.

\subsubsection{Selective broadcasts}
\label{FIDL_Interface_Broadcast_Selective}
The default communication pattern for broadcasts is that each server-initiated
broadcast will be send to \textit{all} connected clients. Optionally, the keyword
\textit{selective} can be given to indicate that the server might send this broadcast
to one or a subset of the connected clients, depending on application logic
and/or deployment information. Example syntax:


\begin{lstlisting}[language=Franca]
interface ExampleInterface {
	broadcast stop selective {
		out { Boolean immediately }
	}
}
\end{lstlisting}

The \textit{selective} keyword will have the following implications:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
The client must be aware that the server has explicitly
		chosen to send the broadcast to it.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
There might be special \textit{register()} functions (or similar)
		generated on client side in order to allow clients to decide
		if they want to be receivers of the selective broadcast(s).
		However, this is not mandatory and will usually be
		configured by the deployment model or defined implicitly
		for a given target platform.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
The server will have the opportunity to select among
		its clients when sending the broadcast (e.g., by code
		especially generated for this reason).

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}


\subsection{Interfaces managing interfaces}
\label{FIDL_Interface_Manages}
\todo[inline]{In this section the manages-concept will be documented.}

\section{Contracts}
\label{FIDL_Contracts}
\subsection{Basic concept of contracts}
\label{FIDL_Contracts_Basic}
For each Franca interface, a \textit{contract} might be specified which defines the 
dynamic behavior of the interface. Generally, if a contract is part of the interface,
all interactions of clients and providers of this interface have to obey the 
specification in the contract. This is different from behavior specification by
sequences (e.g., MSCs in MOST), which provides a set of allowed sequences, but
in general doesn't require that all legal sequences have been specified.

Note that a contract is a specification of the interaction of a pair
of one client instance and one provider instance. If multiple clients
are connected to one interface on provider side, one instance of the
contract is (conceptually) established for each client. 

In order to specify the dynamic behavior of a Franca interface, 
a \textit{PSM} (short for: \textit{Protocol State Machine}) is defined which specifies 
the allowed states \textit{of the connection} and the allowed transitions between those
states. Example:


\begin{lstlisting}[language=Franca]
// specification of dynamic behavior on the interface 
contract {
	PSM {
		initial idle
		state idle {
			on call setActivePlayer -> working
		}
		state working {
			on signal attachOutput -> idle
		}
	}
}
\end{lstlisting}

The client/server connection specified by this interface can have two states:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{idle}: The client is allowed to call the \textit{setActivePlayer} method.
		No other interaction via the interface is allowed.
		This is the initial state.
		If the client calls the \textit{setActivePlayer} method, the state will change to \textit{working}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{working}: The server is allowed to send the broadcast \textit{attachOutput}.
		No other interaction via the interface is allowed.
		After this broadcast has been sent, the state will change to \textit{idle}. 

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Protocol state machines}
\label{FIDL_Contracts_PSM}
The \textit{Protocol State Machines} used for specifying Franca's interface contracts
use \textit{events} to specify the transitions from one state to another.
Valid events might be:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{call}: A method call initiated by the client.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{respond}: The server's response for a client's method call.
		Note that \textit{fireAndForget} methods do not trigger this kind of event
		(see \hyperref[FIDL_Interface_Method_FireAndForget]{Fire-and-forget methods~(�\ref*{FIDL_Interface_Method_FireAndForget})}).

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{signal}: A broadcast sent by the server.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{set}: An attribute's value is being changed by a client.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{update}: An indication by the server that an attribute's value has been changed.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

A transition will be triggered by one out of a set of events. The actual 
transition can be guarded by a boolean condition.

\subsection{Transition actions}
\label{FIDL_Contracts_Actions}
For each transition of a PSM, an optional \textit{action} can be defined.
The action consists of a set of statements which will be executed each time
the transition is triggered. Note that the execution of these statements
will usually not be implemented by real code on the target system. 
Instead, it will be interpreted during some analysis of the interaction
on the interface. 

All \textit{actions} are defined in terms of an \textit{action language}, which is
part of Franca IDL. This action language is purposefully small and simple
in order to allow static analysis and interpretation of the actions.

Here is an example which shows the syntax of actions:

\begin{lstlisting}[language=Franca]
contract {
	PSM {
		initial idle
		state idle {
			on call setActivePlayer -> working {
				// put action code here
			}	
		}
		state working {
			on signal attachOutput -> idle {
				// put action code here
			}
		}
	}
}
\end{lstlisting}

The elements of the action language are still subject to development
and will be described in a later version of this document.   

\subsection{State variables}
\label{FIDL_Contracts_StateVars}
A PSM can refer to \textit{state variables} which have been defined as part
of the contract. The state variables are statically typed.
Any guard or action of a transition can refer to the state variables.
The boolean guards can check the values of either message arguments,
attribute values or state variable values.

The following examples enhances the contract defined above by a state variable
and an action counting the number of \textit{setActivePlayer} method calls.
The two transitions of state \textit{working} are guarded; the guards are checking
the value of the state variable. After 100 interactions, the PSM will
enter state \textit{silence} and will not accept any more events.
The contract specifies an interface which allows a maximum of 100 calls of 
method \textit{setActicePlayer}. As the \textit{silence} state doesn't have any outgoing 
transitions, the system will have to be restarted in order to allow further
activities on this interface.

\begin{lstlisting}[language=Franca]
contract {
	vars {
		UInt32 count;
	}
	PSM {
		initial idle
		state idle {
			on call setActivePlayer -> working {
				count = count + 1
			}	
		}
		state working {
			on signal attachOutput [count<100] -> idle
			on signal attachOutput [count>=100] -> silence
		}
		state silence { }
	}
}
\end{lstlisting}

In a future release of Franca IDL there will be mandatory extensions
for defining the value domains of the state variables (e.g., ranges for 
integer values). This will allow model checking of PSMs. 

\subsection{Exploiting contract information}
\label{FIDL_Contracts_Exploits}
The contract information can be used in a variety of ways:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
Development tools used for the implementation of components could
		use the information to guide the developer through the software design
		process. 

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Test code could be generated on client or server side which 
		checks for correct sequences at runtime.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Target traces can be analysed offline by validating sequences against the contract.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

The \textit{contract}-feature in Franca is still under development. However,
by specifying the proper and allowed behavior of interfaces in a consistent way
the value and expressiveness of interface definitions can be increased to a large extent.

\section{Comments}
\label{FIDL_Comments}
Franca supports two kinds of comments: unstructured and structured comments.

\subsection{Unstructured comments}
\label{FIDL_CommentsUnstructured}
Unstructured comments are usually one-line and multi-line comments as well known
from C, C++ or Java. Examples:


\begin{lstlisting}[language=Franca]
// this is a one-line unstructured comment
typedef TypeOne is UInt8

/* this is a multi-line unstructured comment,
   it could be used also for one-liners :-)    */
typedef TypeTwo is Int16
\end{lstlisting}

\subsection{Structured comments}
\label{FIDL_CommentsStructured}
Structured comments consist of tagged meta-information as known for example from JavaDoc.
Each tag is started with an @-sign. The set of available tags is part of the Franca specification.


\begin{lstlisting}[language=Franca]
<** @description : Currently active player. All other players will
                   reject any requests.
    @author      : E. Wiggin                                      **>
attribute tPlayer activePlayer
\end{lstlisting}

Downstream tools can access the tags and their string content and use them
for analysis and code generation.

All built-in tags are listed in \autoref{CommentTags} together with descriptions.


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-4.0\tabcolsep}
\noindent\begin{tabular}{p{0.22\XdocTEffectiveWidth}p{0.78\XdocTEffectiveWidth}}
\toprule
\textit{Tag}

 & \textit{Description}

\\
\midrule
\protect\lstinline[language=Franca]�@description�

 & A comment with this tag contains a description of the documented
		   interface or datatype element.
		   Typically, the string content of this tag will be used for generated
		   documentation.

\\
\protect\lstinline[language=Franca]�@author�

 & This tag specifies the author of the documented element.

\\
\protect\lstinline[language=Franca]�@deprecated�

 & This tag is used to mark the documented element as deprecated.
		   The string content should point out a better solution which
		   can be used in order to avoid using this element.

\\
\protect\lstinline[language=Franca]�@source-uri�

 & This tag can be used to point to an URI which specifies some kind
		   kind of source information for this element. E.g., if an interface
		   has been created by transformation from a D-Bus introspection file,
		   the source URI could refer to the original D-Bus XML file.

\\
\protect\lstinline[language=Franca]�@source-alias�

 & This tag can be used in addition to \protect\lstinline[language=Franca]�@source-uri� for
		   specifying source elements for the corresponding Franca element.

\\
\protect\lstinline[language=Franca]�@see�

 & A comment with this tag specifies a further reading or any other
		   kind of semantic reference.

\\
\protect\lstinline[language=Franca]�@experimental�

 & An element marked with this tag is not a stable part of the 
		   interface definition.

\\
\protect\lstinline[language=Franca]�@details�

 & This tag is deprecated, it will be removed in a future version.
		   The \protect\lstinline[language=Franca]�@description� tag should be used instead.

\\
\protect\lstinline[language=Franca]�@param�

 & This tag is deprecated, it will be removed in a future version.
		   Instead, the arguments of methods and broadcasts should be documented using
		   the \protect\lstinline[language=Franca]�@description� tag for the corresponding arguments.

\\
\protect\lstinline[language=Franca]�@high-volume�

 & This tag is deprecated, it will be removed in a future version.
		   Specific information related to performance and QoS aspects should be
		   modeled using Franca deployment models.

\\
\protect\lstinline[language=Franca]�@high-frequency�

 & This tag is deprecated, it will be removed in a future version.
		   Specific information related to performance and QoS aspects should be
		   modeled using Franca deployment models.

\\
\bottomrule
\end{tabular}
\caption{List of available tags for structured comments in Franca IDL.}
\label{CommentTags}
\end{table}


\section{Fully qualified names, packages, and multiple files}
\label{FIDL_MultipleFiles}
\subsection{Fully qualified names}
\label{FIDL_MultipleFiles_FQN}
All top-level elements of Franca (i.e., type collections and interfaces)
are accessed by their \textit{fully qualified name}.
A fully qualified name (or short: \textit{FQN}) is a sequence of identifiers (at least one)
separated by dots. The following example shows an interface identified by a FQN: 

\begin{lstlisting}[language=Franca]
interface examples.franca.ExampleInterface {
	// ...
}
\end{lstlisting}

\subsection{Package declarations}
\label{FIDL_MultipleFiles_Package}
Each Franca file starts with a \textit{package}-declaration (similar to Java). 
This puts all type collections and interfaces defined in that file into
the package. The absolute reference for this top-level element is computed
by concatening the package's FQN and the element's FQN. Example:


\begin{lstlisting}[language=Franca]
package org.franca.examples
interface simple.ExampleInterface {
	// this interface can be globally accessed by the FQN
	//   org.franca.examples.simple.ExampleInterface
}
\end{lstlisting}

\subsection{Imports and namespace resolution}
\label{FIDL_MultipleFiles_Imports}
If elements in one Franca file need elements from another file, they can reference
the latter only if a corresponding \textit{import} statement is provided.
There are two kinds of imports. \textit{Model imports} will import all visible 
top-level elements in the imported file. However, these elements have to be
referenced with their absolute FQN. 


\begin{lstlisting}[language=Franca]
package org.franca.examples.demo

// model import
import model "basic_types.fidl"

interface ExampleInterface {
	// ...
}
\end{lstlisting}

\textit{Namespace imports} will import all visible elements in the given namespace of the 
imported file. These elements can be referenced with a FQN which is relative to the 
given namespace.
 

\begin{lstlisting}[language=Franca]
package org.franca.examples.demo

// namespace import
import org.franca.examples.demo.* from "basic_types.fidl"

interface ExampleInterface {
	// ...
}
\end{lstlisting}


\chapter{Franca Tools User's Guide}
\label{FrancaTooling}
\section{Franca IDL Editor}
\label{FrancaTooling_Editor}
The core tool for Franca users is the nice textual editor which can be used
to review and edit Franca IDL files. The Franca IDL Editor is a textual editor
which is similar to Eclipse's text-based editors like in JDT or CDT.
It is provided as Eclipse plugin and can be installed in any Eclipse environment
which provides modeling support.

The following screenshot shows Franca in action:

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{images/franca_editor_screenshot_1.png}
\caption{Screenshot of Franca IDL editor with
	content assist and validation markers.}
\end{figure}

The editor provides syntax highlighting,
code completion, content assist, folding, online validation, a helpful outline view,
jump-to-definition and find-references with shortcuts, and many more features.
See \autoref{KeyboardShortcuts} for a table of most important keyboard short-cuts for Franca.


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-6.0\tabcolsep}
\noindent\begin{tabular}{p{0.25\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}p{0.50\XdocTEffectiveWidth}}
\toprule
\textit{Shortcut}

 & \textit{Function}

 & \textit{Description}

\\
\midrule
Ctrl-/

 & Toggle comment

 & Toggle comment for line / selection.

\\
Ctrl-Space

 & Content Assist

 & Context sensitive suggestions for possible values.

\\
F3 or Ctrl-MouseClick

 & Jump to definition

 & Jumps to the definition of the reference under cursor.

\\
\bottomrule
\end{tabular}
\caption{Most important Eclipse keyboard short-cuts for Franca.}
\label{KeyboardShortcuts}
\end{table}

You may download a nice cheat sheet with more keyboard shortcuts
\href{http://5ise.quanxinquanyi.de/2012/01/13/xtext-end-user-domain-experts-cheat-sheet/}{here}.

\todo[inline]{More detail about the Franca IDL Editor will be provided here later.}

\section{Franca Contract Viewer}
\label{FrancaTooling_ContractViewer}
The dynamic behavior of interfaces can be modeled using protocol state machines
(see section \hyperref[FIDL_Contracts]{Contracts~(�\ref*{FIDL_Contracts})}). As contracts must be an integral part
of a Franca interface, the state machines are modeled in the same textual editor
as the other parts of a Franca interface (as described in the previous section).

In order to understand the structure of the protocol state machine of a contract
quickly, Franca comes with a \textit{Contract Viewer}. In order to use it,
the Franca \textit{User Interface Extension} feature has to be installed in the IDE.
Then, the contract viewer can be opened by selecting \textit{Window > Show View... > Franca}. 

The following screenshot shows the contract viewer:

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{images/contractviewer_screenshot.png}
\caption{Screenshot of Franca Contract Viewer.}
\end{figure}

The "T" button in the upper right of the viewer window toggles the labels for
all transitions of the protocol state machine. If the labels are switched off, 
mouse hovers are available which provide the information about transition conditions. 

\section{Franca IDL HTML Generator}
\label{FrancaTooling_Generators}
The HTML generator for Franca IDL files is provided as Java class
\textit{HTMLGenerator}. It is located in package \textit{org.franca.generators.html}
and provided by Eclipse plugin \textit{org.franca.generators}.
In this plugin, a helper Java class \textit{FrancaGenerators} is provided which
should be used to run the HTML generator:


\begin{lstlisting}[language=Java]
FModel fmodel = FrancaIDLHelpers.instance().loadModel(inputfile);
FrancaGenerators.instance().genHTML(fmodel, "html-gen-dir");
\end{lstlisting}

The HTML generator is implemented using the \href{http://www.xtend-lang.org}{Xtend}
language. The Xtend-builder automatically creates the Java class mentioned
above from this implementation. 


\chapter{Franca Model API}
\label{FrancaModelAPI}
\section{How can Franca models be accessed programmatically?}
\label{FrancaModelGeneral}
The Franca model infrastructure is based on the
\href{http://www.eclipse.org/modeling/emf/}{Eclipse Modeling Framework (EMF)}.
The \hyperref[FrancaConcepts_IDL_CoreModel_Basic]{Franca core model~(�\ref*{FrancaConcepts_IDL_CoreModel_Basic})} is implemented as
a EMF \textit{ecore}-model. EMF provides a tool to generate a Java API from this \textit{ecore}-model.

In Franca, this Java API is provided by the \textit{org.franca.core} Eclipse plugin.
The Java interfaces for the API are located in package \textit{org.franca.core.franca}.

For accessing Franca deployment models programmatically, we recommend to use
the helper classes provided by Franca and the classes automatically generated from
deployment specifications. Thus, we do not include documentation for the EMF
\textit{ecore}-model API of deployment models here. See section
\hyperref[DeploymentModels_DeploymentAccessSupport]{Support for accessing deployment properties~(�\ref*{DeploymentModels_DeploymentAccessSupport})}
for more details about this topic.

\section{Franca Model API Reference}
\label{FrancaModelAPIReference}
\subsection{General remarks}
\label{FrancaModelAPIReference_General}
For each concept of Franca IDL, there is a Java interface in the API.
As all these concepts have names which are quite common in the software
architecture domain, all these API interfaces are prefixed with the
letter "F" (for Franca). Examples: \textit{FInterface}, \textit{FAttribute}, \textit{FMethod}.

The following properties are common for most of these entities:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{name}: most of the Franca API entities have a name.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{comment}: most of the Franca API entities can have a structured comment.
		The structured comment (of type \textit{FAnnotationBlock}) is optional and
		might contain 0..* annotations. 

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{FrancaFactory and FrancaPackage}
\label{FrancaModelAPIReference_FactoryAndPackage}
The API offers a singleton class \textit{FrancaFactory}, which should be used
to create new instances of any model entities. See information about
\href{http://www.eclipse.org/modeling/emf/}{EMF} to find out how the
factory works. The second singleton class of the API is the \textit{FrancaPackage},
which does the initialization of the model and provides meta-information
like ids and others.

Here is a Java code snippet which illustrates how a Franca model element
can be created using the factory.


\begin{lstlisting}[language=Java]
FInterface api = FrancaFactory.eINSTANCE.createFInterface();
api.setName("MediaPlayer");
// and so on
\end{lstlisting}

\section{API for Franca models, interfaces and type collections}
\label{FrancaModelAPIReference_Section_FModel}
This section describes the FModel class, which is the root class for each Franca model.
			It also describes FTypeCollection as well as FInterface and all its elements (e.g.,
			attributes, methods and broadcasts.
			See the section \hyperref[FIDL_Interface]{Interface definition~(�\ref*{FIDL_Interface})} in the Franca User Guide for
			detailed information about interfaces.

\subsection{Class FModel}
\label{FrancaModelAPIReference_FModel}
The root class of a Franca model.
It contains a list of interfaces and a set of type collections.
Other Franca models might be referenced by the 'imports' attribute.
The name of a Franca model is the package declaration. 
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The package declaration for this model file.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_Import]{Import~(�\ref*{FrancaModelAPIReference_Import})}> \textit{imports}: The list of import statements for this model.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}> \textit{interfaces}: The list of interfaces which are defined in this model.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}> \textit{typeCollections}: The list of type collections in this model.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTypeCollection}
\label{FrancaModelAPIReference_FTypeCollection}
A collection of Franca type definitions.
The type collection is named and should be versioned (optional).
Types defined by a \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})} can be referenced from
other \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}s and \hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}s.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name} (optional): The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FVersion]{FVersion~(�\ref*{FrancaModelAPIReference_FVersion})} \textit{version} (optional): The version of this entity. The Apache major/minor scheme is applied.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FType]{FType~(�\ref*{FrancaModelAPIReference_FType})}> \textit{types}: The list of Franca types defined in this entity.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FInterface}
\label{FrancaModelAPIReference_FInterface}
This class represents a Franca interface definition.
Interfaces are named and should be versioned (optional).
Types defined as part of this interface can not be referenced
by other \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}s and \hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}s. This type visibility
differs from the types defined as part of \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}s.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FVersion]{FVersion~(�\ref*{FrancaModelAPIReference_FVersion})} \textit{version} (optional): The version of this entity. The Apache major/minor scheme is applied.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FType]{FType~(�\ref*{FrancaModelAPIReference_FType})}> \textit{types}: The list of Franca types defined in this entity.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FAttribute]{FAttribute~(�\ref*{FrancaModelAPIReference_FAttribute})}> \textit{attributes}: The list of attributes defined for this interface.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})}> \textit{methods}: The list of methods defined by this interface.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FBroadcast]{FBroadcast~(�\ref*{FrancaModelAPIReference_FBroadcast})}> \textit{broadcasts}: The list of broadcasts defined by this interface.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FContract]{FContract~(�\ref*{FrancaModelAPIReference_FContract})} \textit{contract} (optional): The contract of this interface. A contract specifies the semantics of the interface, e.g., the order of the events across this interface.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})} \textit{base} (optional): The base interface. Franca allows single inheritance.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}> \textit{managedInterfaces}: The list of interfaces managed by this interface. The interface will provide methods for discovery and handling of the runtime instances of the managed interfaces. The actual implementation depends on the specific target runtime platform.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FBroadcast}
\label{FrancaModelAPIReference_FBroadcast}
The definition of a Franca broadcast as part of an FInterface.
See the Franca IDL chapter in the Franca User Guide for very
detailed information on broadcast semantics.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FArgument]{FArgument~(�\ref*{FrancaModelAPIReference_FArgument})}> \textit{outArgs}: The parameters of this broadcast.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{selective} (optional): A flag which indicates that this broadcast will not always be send to all clients. The property will be set to a concrete string if the flag is set (e.g., the string "selective"). Do not rely on the actual value of this string. If the property is null, the flag isn't set.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FArgument}
\label{FrancaModelAPIReference_FArgument}
This class represents an argument (aka parameter) for
a \hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})} or FBroadcast. For methods, this might be
an input or output argument. For \hyperref[FrancaModelAPIReference_FBroadcast]{FBroadcast~(�\ref*{FrancaModelAPIReference_FBroadcast})}s, there are only
output arguments (i.e., from server to client).
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{type}: The actual type of this typed element. The type might be predefined or user-defined.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{array} (optional): If the typed element is an implicit array definition, this property will be set to a string (e.g., the string '[]'). If the typed element is a single value (not an array), this property will be null. Do not rely on the actual value of the string.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FMethod}
\label{FrancaModelAPIReference_FMethod}
The definition of a Franca method as part of an FInterface.
Methods without out arguments might have be flagged as
'fireAndForget'. See the Franca IDL chapter in the Franca
User Guide for very detailed information on method semantics.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{fireAndForget} (optional): A flag which indicates that this method will be just a request from client to server without response. The property will be set to a concrete string if the flag is set (e.g., the string "fireAndForget"). Do not rely on the actual value of this string. If the property is null, the flag isn't set. It can be set only for methods without output arguments.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FArgument]{FArgument~(�\ref*{FrancaModelAPIReference_FArgument})}> \textit{inArgs}: The list of input arguments for this method (aka input parameters).

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FArgument]{FArgument~(�\ref*{FrancaModelAPIReference_FArgument})}> \textit{outArgs}: The list of output arguments for this methods (aka return values).

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FEnumerationType]{FEnumerationType~(�\ref*{FrancaModelAPIReference_FEnumerationType})} \textit{errorEnum} (optional): If this property is not null, it represents a definition of method error codes by referencing an enumeration type specified elsewhere. The enumerators of this enumeration type are the error codes the method might return. The enumeration type referenced here might reference a base enumeration. If this property is null, check the errors property instead.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FEnumerationType]{FEnumerationType~(�\ref*{FrancaModelAPIReference_FEnumerationType})} \textit{errors} (optional): If this property is not null, it represents a definition of method error codes by explicitly specifying a list of enumerators. These enumerators are the error codes the method might return. The enumeration type specified here might reference a base enumeration. If this property is null, check the errorEnum property instead.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FAttribute}
\label{FrancaModelAPIReference_FAttribute}
The definition of a Franca attribute as part of an FInterface.
See the Franca IDL chapter in the Franca User Guide for very
detailed information on attribute semantics and the flags
which can be set for attributes.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{type}: The actual type of this typed element. The type might be predefined or user-defined.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{array} (optional): If the typed element is an implicit array definition, this property will be set to a string (e.g., the string '[]'). If the typed element is a single value (not an array), this property will be null. Do not rely on the actual value of the string.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EBoolean \textit{readonly} (optional): Indicates if this attribute is read-only. If false, clients are granted write access to the attribute.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EBoolean \textit{noSubscriptions} (optional): Indicates if clients can subscribe to update events for this attribute. If false, subscribing is possible. The reverse logic of this flag is to ensure a proper default in the IDL: if the keyword "noSubscriptions" is not given, subscription is possible.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FVersion}
\label{FrancaModelAPIReference_FVersion}
The version of this interface or type collection.
It is defined according to the Apache major/minor scheme for interfaces.
I.e., a change in the major number indicates a non-compatible change.
It is mandatory to define both major and minor numbers.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EInt \textit{major}: The major number of this version specification (e.g., the "1" in "1.0").

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EInt \textit{minor}: The minor number of this version specification (e.g., the "0" in "1.0").

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class Import}
\label{FrancaModelAPIReference_Import}
An import declaration.
It defines a namespace from some Franca resource, which
should be imported. All elements from other Franca models
referenced by this model should be member of some
imported Franca model.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{importedNamespace} (optional): The namespace which is addressed by this import.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{importURI} (optional): The URI of the imported resource.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\section{API for Franca types}
\label{FrancaModelAPIReference_Section_FType}
This section describes all API classes needed for Franca type definitions.
			See the section \hyperref[FIDL_Types]{Data types~(�\ref*{FIDL_Types})} in the Franca User Guide for
			detailed information about defining types with Franca.

\subsection{Class FType (abstract)}
\label{FrancaModelAPIReference_FType}
This is the base class for all user-defined Franca types.
It will never be instantiated directly.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FMapType}
\label{FrancaModelAPIReference_FMapType}
The Franca map type (sometimes "map" is also called "dictionary").
This is a collection type which maps objects of a \textit{key} type to objects
of a \textit{value} type in constant time.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{keyType}: The key type which is mapped to the value type. Note: Some IDLs (e.g. D-Bus Introspection) do not allow complex types as keys. Franca doesn't have this restriction.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{valueType}: The value type of this map. It might be a predefined or a user-defined type.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTypeRef}
\label{FrancaModelAPIReference_FTypeRef}
This class is a reference to some Franca type.
It may be either a \hyperref[FIDL_PrimitiveTypes]{primitive
type~(�\ref*{FIDL_PrimitiveTypes})} (property \textit{predefined} or a derived type (e.g., struct, array, map).
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
FBasicTypeId \textit{predefined} (optional): If the referenced type is a predefined type, this property gives the actual predefined type. If the reference type is a user-defined type, this property will be null.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FType]{FType~(�\ref*{FrancaModelAPIReference_FType})} \textit{derived} (optional): If the referenced type is a user-defined type, this property gives the actual complex type definition. If the reference type is a predefined type, this property will be null.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Enum FBasicTypeId}
\label{FrancaModelAPIReference_FBasicTypeId}
This enum represents the basic types available in Franca IDL.
See section \hyperref[FIDL_PrimitiveTypes]{Primitive types~(�\ref*{FIDL_PrimitiveTypes})} in the
Franca User Guide for a list of available primitive types and their semantics.

This enum consists of the following literals:  
\textit{UNDEFINED}, \textit{INT8}, \textit{UINT8}, \textit{INT16}, \textit{UINT16}, \textit{INT32}, \textit{UINT32}, \textit{INT64}, \textit{UINT64}, \textit{BOOLEAN}, \textit{STRING}, \textit{FLOAT}, \textit{DOUBLE}, \textit{BYTE\_BUFFER}.

\subsection{Class FEnumerationType}
\label{FrancaModelAPIReference_FEnumerationType}
This class represents an enumeration type. The enumeration will contain
a list of \textit{enumerators}. It can be derived from a base enumeration.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FEnumerator]{FEnumerator~(�\ref*{FrancaModelAPIReference_FEnumerator})}> \textit{enumerators}: The list of enumerators of this enumeration.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FEnumerationType]{FEnumerationType~(�\ref*{FrancaModelAPIReference_FEnumerationType})} \textit{base} (optional): The base type of this enumeration. Will be null if this enumeration is not derived from any other enumeration.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FEnumerator}
\label{FrancaModelAPIReference_FEnumerator}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{value} (optional): The value of this enumerator. As the value definition for an enumerator is optional, value might be null.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTypeDef}
\label{FrancaModelAPIReference_FTypeDef}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{actualType}: The actual type for this type alias.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FCompoundType (abstract)}
\label{FrancaModelAPIReference_FCompoundType}
This class represents all kinds of compound types in Franca, i.e., struct and union types.
A compound type has a list of fields; each field is itself specified by its type.
Thus, nested compounds can be created.
The ordering of fields in the compound is relevant. E.g., serialization code
generated from a Franca interface must take into account the order of the fields.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FField]{FField~(�\ref*{FrancaModelAPIReference_FField})}> \textit{elements}: The elements (aka fields) of this compound type.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FUnionType}
\label{FrancaModelAPIReference_FUnionType}
This class represents a union type in Franca. See its base class
\hyperref[FrancaModelAPIReference_FCompoundType]{FCompoundType~(�\ref*{FrancaModelAPIReference_FCompoundType})}
for a detailed description.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FField]{FField~(�\ref*{FrancaModelAPIReference_FField})}> \textit{elements}: The elements (aka fields) of this compound type.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FCompoundType]{FCompoundType~(�\ref*{FrancaModelAPIReference_FCompoundType})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FUnionType]{FUnionType~(�\ref*{FrancaModelAPIReference_FUnionType})} \textit{base} (optional): The base union from which this union inherits. Franca supports single inheritance for unions.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FStructType}
\label{FrancaModelAPIReference_FStructType}
This class represents a struct type in Franca. See its base class
\hyperref[FrancaModelAPIReference_FCompoundType]{FCompoundType~(�\ref*{FrancaModelAPIReference_FCompoundType})}
for a detailed description.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FField]{FField~(�\ref*{FrancaModelAPIReference_FField})}> \textit{elements}: The elements (aka fields) of this compound type.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FCompoundType]{FCompoundType~(�\ref*{FrancaModelAPIReference_FCompoundType})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FStructType]{FStructType~(�\ref*{FrancaModelAPIReference_FStructType})} \textit{base} (optional): The base struct from which this struct inherits. Franca supports single inheritance for structs. Structs which inherit from a base struct cannot be polymorphic.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EBoolean \textit{polymorphic} (optional): Indicates if struct is the root of a polymorphic type hierarchy. Structs may be either extended from a base struct or polymorphic (or none of both).

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FField}
\label{FrancaModelAPIReference_FField}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{type}: The actual type of this typed element. The type might be predefined or user-defined.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{array} (optional): If the typed element is an implicit array definition, this property will be set to a string (e.g., the string '[]'). If the typed element is a single value (not an array), this property will be null. Do not rely on the actual value of the string.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FArrayType}
\label{FrancaModelAPIReference_FArrayType}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{elementType}: The type of this array's elements.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\section{API for Franca contracts}
\label{FrancaModelAPIReference_Section_FContract}
This section describes all API classes needed for Franca interface contracts. 
			The root class of the interface contract subtree is FContract.
			See the section \hyperref[FIDL_Contracts]{Contracts~(�\ref*{FIDL_Contracts})} in the Franca User Guide for
			detailed information about contracts.

\subsection{Class FContract}
\label{FrancaModelAPIReference_FContract}
The contract for a Franca interface.
The contract specifies the dynamic behaviour of the interface.
It consists of a PSM (short for: Protocol State Machine) and
an optional set of state variables.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FStateGraph]{FStateGraph~(�\ref*{FrancaModelAPIReference_FStateGraph})} \textit{stateGraph}: The protocol state machine for this contract. It might use the state variables specified by the variables property.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FDeclaration]{FDeclaration~(�\ref*{FrancaModelAPIReference_FDeclaration})}> \textit{variables}: The declarations of all state variables used by the protocol state machine of this contract.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FDeclaration}
\label{FrancaModelAPIReference_FDeclaration}
This class represents the definition of a state variable
as part of a Franca interface contract. Note that the 
types available for the state variable definition are 
all types which are accessible from this interface.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{type}: The actual type of this typed element. The type might be predefined or user-defined.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{array} (optional): If the typed element is an implicit array definition, this property will be set to a string (e.g., the string '[]'). If the typed element is a single value (not an array), this property will be null. Do not rely on the actual value of the string.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FStateGraph}
\label{FrancaModelAPIReference_FStateGraph}
A state graph specifying the interface's dynamic behavior. The state graph is flat
(i.e., non-hierarchical) and consists of a set of states, which are linked by transitions.
One of the states in the set is specified as \textit{initial}. I.e., this is the initial state of the interface.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FState]{FState~(�\ref*{FrancaModelAPIReference_FState})} \textit{initial}: This property references the initial state for the protocol state machine.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FState]{FState~(�\ref*{FrancaModelAPIReference_FState})}> \textit{states}: The list of states comprising this protocol state machine. It contains the intial state.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FState}
\label{FrancaModelAPIReference_FState}
This class represents a single state as member of a 
\hyperref[FrancaModelAPIReference_FStateGraph]{FStateGraph~(�\ref*{FrancaModelAPIReference_FStateGraph})}.
The state contains a list of its outgoing transitions. 
The target state of each transition is contained in that transition.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FTransition]{FTransition~(�\ref*{FrancaModelAPIReference_FTransition})}> \textit{transitions}: The list of outgoing transitions for this state. These transitions lead to the successor states of this state.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTransition}
\label{FrancaModelAPIReference_FTransition}
This class represents a single transition as part of a 
\hyperref[FrancaModelAPIReference_FStateGraph]{FStateGraph~(�\ref*{FrancaModelAPIReference_FStateGraph})}.
The transition references its target state by property \textit{to}. 
It doesn't reference its source state; instead, the source state contains
the list of its outgoing transitions.
The transition defines a \textit{trigger}, which specifies some event which
can occur during runtime. It also defines a \textit{guard} condition.
If the trigger event occurs, the guard condition will be checked (if any).
Depending on this check the transition will be executed.
Finally, a transition has some \textit{action}, which will be executed
each time when the transition fires.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTrigger]{FTrigger~(�\ref*{FrancaModelAPIReference_FTrigger})} \textit{trigger}: The trigger which fires this transition.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FGuard]{FGuard~(�\ref*{FrancaModelAPIReference_FGuard})} \textit{guard} (optional): An optional guard for this transition.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FState]{FState~(�\ref*{FrancaModelAPIReference_FState})} \textit{to}: The target state of this transition.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})} \textit{action} (optional): An optional action which is executed each time this transition fires.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FExpression (abstract)}
\label{FrancaModelAPIReference_FExpression}
This is the common base class for all expressions of
the Franca contract action language.
The \hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})} class will never be instantiated.

\subsection{Class FBinaryOperation}
\label{FrancaModelAPIReference_FBinaryOperation}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})} \textit{left}: The left operand of the binary operation.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{op}: The operator of this binary operation (e.g., '||', '+', '*', '<', and many more). Consider the FrancaIDL.xtext grammar definition for an overview of all binary operators supported by Franca contract action language.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})} \textit{right}: The right operand of the binary operation.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FConstant (abstract)}
\label{FrancaModelAPIReference_FConstant}
This is the common base class for all kinds of
constants in the Franca contract action language.
The most important types are integers, booleans and strings.

\subsection{Class FStringConstant}
\label{FrancaModelAPIReference_FStringConstant}
This class represents strings constants in the Franca contract action language.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{val}: The value of this string constant (an actual string).

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FBooleanConstant}
\label{FrancaModelAPIReference_FBooleanConstant}
This class represents boolean constants in the Franca contract action language.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EBoolean \textit{val}: The value of this boolean constant (an actual boolean).

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FIntegerConstant}
\label{FrancaModelAPIReference_FIntegerConstant}
This class represents integer constants in the Franca contract action language.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EInt \textit{val}: The value of this integer constant (an actual integer).

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTypedElementRef}
\label{FrancaModelAPIReference_FTypedElementRef}
This class is a reference to some \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.
If the referenced element is no compound type (i.e., struct or union), only the \textit{element} property
will be used. The \textit{target} and \textit{field} properties will be null. If a field of a compound type is referenced,
the \textit{field} property will point to the \hyperref[FrancaModelAPIReference_FField]{FField~(�\ref*{FrancaModelAPIReference_FField})} object. 
If the compound type is nested, the \textit{target} property will reference the next outer level
(which is itself a compound referenced by a \hyperref[FrancaModelAPIReference_FTypedElementRef]{FTypedElementRef~(�\ref*{FrancaModelAPIReference_FTypedElementRef})}. 
This might be chained in order to specify a reference to a deeply nested compound element.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})} \textit{element} (optional): The typed element which is actually referenced by this object.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypedElementRef]{FTypedElementRef~(�\ref*{FrancaModelAPIReference_FTypedElementRef})} \textit{target} (optional): For nested compound types, this property references the next outer level. Otherwise, it is null.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FField]{FField~(�\ref*{FrancaModelAPIReference_FField})} \textit{field} (optional): Specifies the field of a compound type.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTypedElement (abstract)}
\label{FrancaModelAPIReference_FTypedElement}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{type}: The actual type of this typed element. The type might be predefined or user-defined.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{array} (optional): If the typed element is an implicit array definition, this property will be set to a string (e.g., the string '[]'). If the typed element is a single value (not an array), this property will be null. Do not rely on the actual value of the string.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FVariable}
\label{FrancaModelAPIReference_FVariable}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{name}: The name of this element.
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAnnotationBlock]{FAnnotationBlock~(�\ref*{FrancaModelAPIReference_FAnnotationBlock})} \textit{comment} (optional): The structured comment for this element (if any).
		 Inherited from base class FModelElement.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})} \textit{type}: The actual type of this typed element. The type might be predefined or user-defined.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{array} (optional): If the typed element is an implicit array definition, this property will be set to a string (e.g., the string '[]'). If the typed element is a single value (not an array), this property will be null. Do not rely on the actual value of the string.
		 Inherited from base class \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FAssignment}
\label{FrancaModelAPIReference_FAssignment}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FDeclaration]{FDeclaration~(�\ref*{FrancaModelAPIReference_FDeclaration})} \textit{lhs}: The left-hand side of this assignment. It references the state variable which should be set by specifying its declaration.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})} \textit{rhs}: The right-hand side of an assignment. This may be an arbitrary expression of the Franca contract action language.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FBlockExpression}
\label{FrancaModelAPIReference_FBlockExpression}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})}> \textit{expressions}: The sequence of expressions represented by this block. This is a composite pattern used to specify a tree of expressions.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FGuard}
\label{FrancaModelAPIReference_FGuard}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FExpression]{FExpression~(�\ref*{FrancaModelAPIReference_FExpression})} \textit{condition}: The boolean condition of this transition guard.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FTrigger}
\label{FrancaModelAPIReference_FTrigger}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FEventOnIf]{FEventOnIf~(�\ref*{FrancaModelAPIReference_FEventOnIf})} \textit{event}: The event which will trigger this transition.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FEventOnIf}
\label{FrancaModelAPIReference_FEventOnIf}
This class represents a communication event,
which basically corresponds to a message on the interface.
Exactly one of its properties should be set, all other should be zero.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})} \textit{call} (optional): If this property is not null, this event represents the calling of a Franca method by a client.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})} \textit{respond} (optional): If this property is not null, this event represents the response of a Franca method by the server.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FBroadcast]{FBroadcast~(�\ref*{FrancaModelAPIReference_FBroadcast})} \textit{signal} (optional): If this property is not null, this event represents the sending of a Franca broadcast by the server.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAttribute]{FAttribute~(�\ref*{FrancaModelAPIReference_FAttribute})} \textit{set} (optional): If this property is not null, this event represents the setting of a Franca attribute.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\hyperref[FrancaModelAPIReference_FAttribute]{FAttribute~(�\ref*{FrancaModelAPIReference_FAttribute})} \textit{update} (optional): If this property is not null, this event represents the update action of a Franca attribute.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\section{API for Franca structured comments}
\label{FrancaModelAPIReference_Section_FAnnotationBlock}
This section describes the API classes representing structured comments. 
			Note that it is a special feature of Franca that comments are available at all
			in the model. This is not the case for unstructured comments, which basically
			will be removed by the parser when creating the abstract syntax tree.
			See the section \hyperref[FIDL_CommentsStructured]{Structured comments~(�\ref*{FIDL_CommentsStructured})} in the
			Franca User Guide for detailed information about structured comments.

\subsection{Class FAnnotationBlock}
\label{FrancaModelAPIReference_FAnnotationBlock}
This class represents a structured comment.
It is used by many of the elements of the Franca IDL model.
A structured comment consists of a list of elements with one tagged comment each.
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
List<\hyperref[FrancaModelAPIReference_FAnnotation]{FAnnotation~(�\ref*{FrancaModelAPIReference_FAnnotation})}> \textit{elements}: The elements of this annotation block. Each element represents one tagged comment.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Class FAnnotation}
\label{FrancaModelAPIReference_FAnnotation}
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
FAnnotationType \textit{type} (optional): The tag of this comment (i.e., the type of this annotation).

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
EString \textit{comment} (optional): The actual comment as part of an FAnnotation.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\subsection{Enum FAnnotationType}
\label{FrancaModelAPIReference_FAnnotationType}
This enum represents the type of a structured comment (i.e., the tag starting with a '@').

This enum consists of the following literals:  
\textit{DESCRIPTION}, \textit{AUTHOR}, \textit{EXPERIMENTAL}, \textit{DEPRECATED}, \textit{SEE}, \textit{PARAM}, \textit{HIGH\_VOLUME}, \textit{HIGH\_FREQUENCY}, \textit{SOURCE\_URI}, \textit{SOURCE\_ALIAS}, \textit{DETAILS}.


\chapter{Franca Deployment Models}
\label{DeploymentModels}
Franca deployment models offer the possibility to enhance Franca IDL interface
specifications with additional information. This is a way to ensure that Franca IDL
interfaces contain the core information needed to describe the semantics of APIs.
All additional information is stored in some deployment model.

\autoref{DeploymentSupport} shows how Franca supports the various artifacts which have
to be described when defining software architectures. The base elements are 
\textit{interface definitions}. Those are completely supported by the Franca IDL. 
All other architecture artifacts are based on these interface definitions,
among them:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
interface instances or ports,

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
components like servers providing interface instances, as well as clients
		requiring interface	instances,

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
architectural layers where these components live,

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
and the actual transport layer properties with aspects like 
		serialization, encoding or quality of service.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\begin{figure}[!ht]
\centering
\includegraphics[width=0.50\textwidth]{images/franca_idl_and_deploy_overview.png}
\caption{Architecture and interface artifacts and how Franca supports their definition.}
\label{DeploymentSupport}
\end{figure}

This information is typically supported by Franca's configurable deployment models.
However, Franca deployment models will not completely replace architecture definition
languages (ADLs) or UML models. Instead, deployment models provide a means to store
all information which is directly related to Franca interfaces. The deployment information
usually \textit{refines} the interfaces defined in Franca IDL.

Contents of Franca deployment models are related to the implementation
of the interfaces on a target platform and the actual deployment of these
interfaces on the platform. Some examples for this kind of data:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
How are the data types encoded on the target platform (e.g., endianness, padding)?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Are calls blocking or non-blocking?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
How can the instances of an interface be found and addressed (i.e., service discovery)?

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Which quality-of-service promises are valid?

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

The section \hyperref[FrancaConcepts_AddingFeatures]{Guidelines for adding new features to Franca IDL~(�\ref*{FrancaConcepts_AddingFeatures})}
in the \hyperref[FrancaConcepts]{Concepts~(�\ref*{FrancaConcepts})} chapter provides some guidelines
for deciding whether new features belong to the Franca IDL itself or to
the deployment model.

The actual information in a deployment model depends heavily on the target IPC framework.
Therefore, there is no generic deployment model (on a similar abstraction level as
Franca IDL itself). Instead, the properties of the actual deployment model for the
target platform can only be defined with the target platform in mind. This requires
a flexible deployment modeling language which can be used to define the specification
of the required deployment information as well as the actual property values for the
concrete interfaces defined with Franca IDL.

\section{Deployment model concepts}
\label{DeploymentModels_Concepts}
This section explains some basic concepts of Franca deployment models.

\subsection{Deployment specifications and definitions}
\label{DeploymentModels_Concepts_Toplevel}
An interface defined with Franca IDL is independent of any target platform. 
Some code generator will be used to map this interface onto a real target platform,
e.g., generating C++ classes and their implementations in order to implement
the interface on a system were components are connected with D-Bus or another 
IPC mechanism.

In many cases, this generator will need additional information, which does
not belong into the IDL definition. This information will be stored in an instance
of Franca's deployment models. In order to do this, a separate Franca Deployment Language
is available, which consists of two parts:
\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{specification} of deployment properties (done only once per deployment target platform)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{definition} of actual values for deployment properties (done for every Franca interface
		which has to be deployed on the target platform)

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

\autoref{DeploymentOverview} shows how \textit{deployment specifications}, \textit{deployment definitions} and
the actual Franca IDL interfaces are related. A specification is created for a given target
platform (or code generator for this platform). Based on this specification, one deployment
\textit{definition} has to be provided for each actual Franca IDL interface. The specification
describes which additional information has to be provided for an interface on this target
platform - the definition lists this information for one concrete interface.
  
\begin{figure}[!ht]
\centering
\includegraphics[width=0.70\textwidth]{images/franca_deployment_interfaces.png}
\caption{Franca deployment: specifications, definitions and actual interfaces.}
\label{DeploymentOverview}
\end{figure}

It is important to remember here that each Franca IDL interface can be deployed on 
many different target platforms. Thus, there might be many deployment definitions
(based on different deployment specifications) for the same interface. This is essentially
the advantage of the IDL/deployment separation: The core part of each interface definition
(the Franca IDL part) can be re-used in multiple environments.

\subsection{Deployment properties}
\label{DeploymentModels_Concepts_Properties}
\textit{Properties} are the basic units of information in deployment models.
Each specification defines which properties are available by defining their \textit{name},
their \textit{type}, their \textit{host} and some flags (e.g., a default value for the property, or
if the property is mandatory or optional). Properties can be defined freely; there
are no predefined properties. This ensures maximum flexibility when writing specifications.

The following example shows one property as part of a deployment specification.
The property is named \textit{PerformanceImpact}; it is located at the host \textit{methods}.
The property is of \textit{enumeration} type, with enum values \textit{none}, \textit{medium} and
\textit{substantial}. It has the flag \textit{optional}.


\begin{lstlisting}[language=FDeploy]
specification MySpec
{
	for methods {
		PerformanceImpact: {none, medium, substantial}   (optional);
	}
}
\end{lstlisting}

The \textit{host} attribute of a property defines at what locations in a definition
this property applies; this is a similar concept as \textit{pointcuts} in aspect-oriented
programming (but there are also some differences to that concept).

There is a variety of hosts; \autoref{DeploymentInterfaceHostsPart1} and
\autoref{DeploymentInterfaceHostsPart2} list those related to
Franca interfaces. Note that the properties for some hosts will
be applied to several locations of a Franca IDL interface.


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-8.0\tabcolsep}
\noindent\begin{tabular}{p{0.13\XdocTEffectiveWidth}p{0.38\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}}
\toprule
\textit{Host}

 & \textit{Description}

 & \textit{Impacted Franca IDL elements}

 & \textit{Example}

\\
\midrule
\protect\lstinline[language=FDeploy]�interfaces�

 & Properties related to whole Franca IDL interfaces (but not its instances)

 & \protect\lstinline[language=Franca]�interface�

 & locally or globally accessible?

\\
\protect\lstinline[language=FDeploy]�type_collections�

 & Properties related to Franca type collections

 & \protect\lstinline[language=Franca]�typeCollection�

 & type visibility

\\
\protect\lstinline[language=FDeploy]�attributes�

 & Properties related to attributes of a Franca IDL interface

 & \protect\lstinline[language=Franca]�attribute�

 & flag: read-only or read/write?

\\
\protect\lstinline[language=FDeploy]�methods�

 & Properties related to methods of a Franca IDL interface

 & \protect\lstinline[language=Franca]�method�

 & calling style (blocking / non-blocking)

\\
\protect\lstinline[language=FDeploy]�broadcasts�

 & Properties related to broadcasts of a Franca IDL interface

 & \protect\lstinline[language=Franca]�broadcast�

 & priority

\\
\protect\lstinline[language=FDeploy]�arguments�

 & Properties related to the arguments of methods and broadcasts

 & input and output arguments of \protect\lstinline[language=Franca]�method�, output arguments of \protect\lstinline[language=Franca]�broadcast�

 & flag: is optional?

\\
\bottomrule
\end{tabular}
\caption{Franca deployment: Property hosts related to interface elements.}
\label{DeploymentInterfaceHostsPart1}
\end{table}


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-8.0\tabcolsep}
\noindent\begin{tabular}{p{0.13\XdocTEffectiveWidth}p{0.38\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}}
\toprule
\textit{Host}

 & \textit{Description}

 & \textit{Impacted Franca IDL elements}

 & \textit{Example}

\\
\midrule
\protect\lstinline[language=FDeploy]�structs�

 & Properties related to struct definitions

 & \protect\lstinline[language=Franca]�struct�

 & alignment / padding

\\
\protect\lstinline[language=FDeploy]�struct_fields�

 & Properties related to fields of struct definitions

 & fields of \protect\lstinline[language=Franca]�struct�

 & alignment / padding

\\
\protect\lstinline[language=FDeploy]�unions�

 & Properties related to union definitions

 & \protect\lstinline[language=Franca]�union�

 & flag for tag generation

\\
\protect\lstinline[language=FDeploy]�union_fields�

 & Properties related to fields of union definitions

 & fields of \protect\lstinline[language=Franca]�union�

 & explicit tag for each field

\\
\protect\lstinline[language=FDeploy]�enumerations�

 & Properties related to enumeration definitions

 & \protect\lstinline[language=Franca]�enumeration�

 & flag: generate enum values?

\\
\protect\lstinline[language=FDeploy]�enumerators�

 & Properties related to enumerators

 & values of \protect\lstinline[language=Franca]�enumeration�

 & renaming, filtering

\\
\protect\lstinline[language=FDeploy]�arrays�

 & Properties related to array definitions

 & \protect\lstinline[language=Franca]�array�

 & alignment, maximum length

\\
\protect\lstinline[language=FDeploy]�strings�

 & Properties related to string variables

 & all entities with predefined type \protect\lstinline[language=Franca]�String�:
			\protect\lstinline[language=Franca]�attribute� members,
			arguments of \protect\lstinline[language=Franca]�method� and \protect\lstinline[language=Franca]�broadcast�,
			\protect\lstinline[language=Franca]�struct� fields

 & encoding (ASCII, Unicode, ...)

\\
\protect\lstinline[language=FDeploy]�integers�

 & Properties related to all integer numbers

 & all entities with predefined type \protect\lstinline[language=Franca]�Int8�, \protect\lstinline[language=Franca]�UInt8�, ...:
			\protect\lstinline[language=Franca]�attribute� members,
			arguments of \protect\lstinline[language=Franca]�method� and \protect\lstinline[language=Franca]�broadcast�,
			\protect\lstinline[language=Franca]�struct� fields

 & allowed range, little vs. big endian

\\
\protect\lstinline[language=FDeploy]�floats�

 & Properties related to all float numbers

 & all entities with predefined type \protect\lstinline[language=Franca]�Float� or \protect\lstinline[language=Franca]�Double�:
			\protect\lstinline[language=Franca]�attribute� members,
			arguments of \protect\lstinline[language=Franca]�method� and \protect\lstinline[language=Franca]�broadcast�,
			\protect\lstinline[language=Franca]�struct� fields

 & encoding (ISO...)

\\
\protect\lstinline[language=FDeploy]�numbers�

 & Properties related to integer or float numbers

 & all entities of \protect\lstinline[language=FDeploy]�integers� and \protect\lstinline[language=FDeploy]�floats� combined

 & alignment

\\
\bottomrule
\end{tabular}
\caption{Franca deployment: Property hosts related to interface data types.}
\label{DeploymentInterfaceHostsPart2}
\end{table}

In a deployment \textit{definition} for a given specification, concrete \textit{values} 
have to be assigned to each property. Depending on the \textit{host} definition and the
optional/default flags on the specification side, properties will be mandatory at
certain locations. This will be enforced by the deployment model editor and 
the underlying validation checks.

\subsection{Providers and interface instances}
\label{DeploymentModels_Concepts_Providers}
Most properties will be attached to concrete locations of Franca interfaces,
like methods, arguments or similar entities. However, the scope of the deployment concept
usually contains components which provide interfaces (i.e., servers). Moreover,
interface providers might offer several interfaces and even multiple instances of
the same interface. Deployment models often have to support this, e.g., in order to
define network addresses on the interface instance level. 

These concepts are supported by Franca deployment models by the \textit{host} definitions
\textit{providers} and \textit{instances}.
\autoref{DeploymentProviderHosts} lists the property hosts
related to providers and interface instances.


\begin{table}
\setlength{\XdocTEffectiveWidth}{\textwidth}
\addtolength{\XdocTEffectiveWidth}{-8.0\tabcolsep}
\noindent\begin{tabular}{p{0.13\XdocTEffectiveWidth}p{0.38\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}p{0.25\XdocTEffectiveWidth}}
\toprule
\textit{Host}

 & \textit{Description}

 & \textit{Impacted Franca IDL elements}

 & \textit{Example}

\\
\midrule
\protect\lstinline[language=FDeploy]�providers�

 & Properties of interface providers

 & n/a

 & process name, deployment node

\\
\protect\lstinline[language=FDeploy]�instances�

 & Properties related to instances of a Franca IDL interface (e.g., port)

 & n/a

 & network address of the interface instance

\\
\bottomrule
\end{tabular}
\caption{Franca deployment: Property hosts related to providers and interface instances.}
\label{DeploymentProviderHosts}
\end{table}

\section{Defining deployment specifications}
\label{DeploymentModels_Specifications}
This section explains how deployment specifications for a concrete target platform
are defined.

\subsection{Introductory example}
\label{DeploymentModels_Specifications_SimpleExample}
Let's start with a concrete deployment example. The following deployment model
contains both the specifiation part and the definition part.
In the \textit{specification}, the two properties \textit{CallSemantics} and \textit{IsOptional}
are introduced. Both are defined for the \textit{methods} host, which indicates that
those properties will be relevant for all methods defined in a Franca IDL interface. 

The property \textit{CallSemantics} has an enumeration type with the constant values
\textit{synchronous} and \textit{asynchronous}. As there is no further flag here, the property
is mandatory and has to be set for all methods under the given specification \textit{MySpec}.
The property \textit{IsOptional} of boolean type is also mandatory. Using this specification,
it has to be specified for every method of a Franca IDL interface if the method is
called synchronously or asynchronously (property \textit{CallSemantics}) 
and if the method has to be implemented by the server or not (property \textit{IsOptional}). 


\begin{lstlisting}[language=FDeploy]
import "PlayerAPI.fidl"

specification MySpec
{
	for methods {
		CallSemantics: {synchronous, asynchronous};
		IsOptional:    Boolean;
	}
}

define MySpec for interface PlayerAPI
{
	method setActivePlayer {
		CallSemantics = synchronous
		IsOptional = false
	}
}
\end{lstlisting}

The second part of the introductory example shows the application of the
specification \textit{MySpec} for the Franca interface \textit{PlayerAPI}. In order to write
this deployment definition, an \textit{import} statement has to be given at the
beginning which includes the \textit{fidl}-file which contains the interface definition.

The example interface \textit{PlayerAPI} contains exactly one method. In the deployment
definition, we now have to enrich this method with the two mandatory properties defined
in the specification. In the example, we define that method \textit{setActivePlayer} will
be called synchronously and has to be provided by every server offering the
interface \textit{PlayerAPI}.

Note: For typical applications of the deployment modeling concept, specifications
and definitions will be stored as separate file. This is because usually the specification
will be owned by a platform architect or a framework team, whereas the actual definitions
will be created by the responsible architects and developers, who also define the
actual interfaces with Franca IDL. 

\subsection{Deployment specification for interfaces}
\label{DeploymentModels_Specifications_Interfaces}
This section provides a more elaborate example of deployment specifications.
It shows the full range of types, single types vs. arrays. It also shows how to
define default values for properties. Note that the actual names of properties 
(and all their attributes) can be freely chosen by the specification designer. 
There are no predefined properties. However, the designer has to ensure that 
property names will be unique (the deployment editor will take care of this
by validating the property names online).

The specification name is fully qualified in order to allow a hierarchical 
organization of specifications. Each property can be either defined as single
value or as array. For example, property \protect\lstinline[language=FDeploy]{Range} has been defined
as array of integers, and the default value is an array which contains the 
values 1, 2 and 3. Property \protect\lstinline[language=FDeploy]{Groups} is an array of enumeration
values g1, g2, g3 and g4. Thus, values for this property might be an arbitrary subset
of this enumeration.


\begin{lstlisting}[language=FDeploy]
specification org.deployspecs.SampleDeploySpec
{
	for methods {
		CallSemantics: {synchronous, asynchronous} (default: asynchronous);
		Priority:      {low, medium, high}         (default: low);		
		IsOptional:    Boolean;
		Range:         Integer[]                   (default: {1, 2, 3});
	}
	
	for attributes {
		IsReadOnly:    Boolean                     (default: false);
		Groups:        {g1, g2, g3, g4}[];
	}
	
	for strings {
		Encoding:      {utf8, unicode};
	}
}
\end{lstlisting}

The example shows some properties for which reasonable default values have been defined.
All properties which are neither optional nor have defaults are \textit{mandatory}. Those
properties must be defined at all impacted locations of the deployment definition
(the locations are determined by the \textit{host} of the property).

\subsection{Providers and interface instances}
\label{DeploymentModels_Specifications_Providers}
This is a specification for the deployment of IP-based IPC stacks. This is just an
example, an actual deployment specification for IP-based stacks will have to take
into account more platform-specific details.


\begin{lstlisting}[language=FDeploy]
specification org.deployspecs.IPBasedIPC
{
	for providers {
		ProcessName:     String;
	}

	for instances {
		IPAddress:       String;
		Port:            Integer                     (optional);	
		AccessControl:   { local, subnet, global }   (default: global);
	}
}
\end{lstlisting}

The interesting part of this example is the usage of the property \textit{hosts}
\protect\lstinline[language=FDeploy]{providers} and \protect\lstinline[language=FDeploy]{instances}. Those properties will
not be related to actual entities of a Franca IDL interface, but to some additional 
architecture-related parts instead. This is depicted by the outer ring in 
the overview diagram at the beginning of this chapter. 

\subsection{Specification Inheritance}
\label{DeploymentModels_Specifications_SpecificationInheritance}
Specifications can inherit from base specifications. Example:


\begin{lstlisting}[language=FDeploy]
specification org.deployspecs.DerivedSpec
	extends org.deployspecs.IPBasedIPC
{
	// put specification details here
}
\end{lstlisting}

This allows to build a hierarchy of specifications (i.e., a specification ontology).

\subsection{The property datatype 'Interface'}
\label{DeploymentModels_Specifications_InterfaceAsDatatype}
Each property defined in a deployment specification is strongly typed.
In the examples above, the datatypes \protect\lstinline[language=FDeploy]{Boolean}, \protect\lstinline[language=FDeploy]{Integer},
\protect\lstinline[language=FDeploy]{String} and ad-hoc enumerations have been used.

In some use cases, it is necessary to establish relationships between Franca interface
definitions. E.g., in a large-scale system each functional interface might have a
corresponding diagnostics interface providing additional functionality used for testing
and observation.

The following example shows how a property with the datatype \protect\lstinline[language=FDeploy]{Interface}
is defined. In the example, for each Franca interface the \textit{Master} property can be 
set in order to define another interface which is the master of this interface. 
The example also defines a specific interface reference \textit{\&org.example.idl.Controller}
as a default value.
  

\begin{lstlisting}[language=FDeploy]
specification org.deployspecs.Channel
{
	for interfaces {
		Master:   Interface (default: &org.example.idl.Controller);
	}

	// put more specification details here
}
\end{lstlisting}

Note that the \protect\lstinline[language=FDeploy]{Interface} datatype allows to refer to interface
\textit{definitions}, not interface \textit{instances}. If you are looking for a way to
establish relations between interface instances, the \protect\lstinline[language=Franca]{manages} concept
might be a proper solution (see section
\hyperref[FIDL_Interface_Manages]{Interfaces managing interfaces~(�\ref*{FIDL_Interface_Manages})}).

\section{Defining deployment definitions}
\label{DeploymentModels_Definitions}
This section describes how deployment definitions are created based on 
deployment specifications.

\subsection{Interface deployment}
\label{DeploymentModels_Definitions_Interfaces}
This section provides a more elaborate example of deployment definitions for
a Franca interface. The specification for this deployment is located in the
separate file \textit{SampleDeploySpec.fdepl}, which is imported in the first line
of the example. The second line is another import statement; it imports the
actual France IDL interface which should be refined by the deployment data 
in the remaining parts of this file.

The deployment definition for the interface \textit{PlayerAPI} explicitly references
the specification \textit{SampleDeploySpec}. You should compare this example with 
the specification from section
\hyperref[DeploymentModels_Specifications_Interfaces]{Deployment specification for interfaces~(�\ref*{DeploymentModels_Specifications_Interfaces})}.


\begin{lstlisting}[language=FDeploy]
import "deployspecs/SampleDeploySpec.fdepl"
import "../franca/demo1.fidl"

define SampleDeploySpec for interface org.franca.examples.demo.PlayerAPI
{
	attribute activePlayer {
		IsReadOnly = true
		Groups = { g1, g2 }
	}
	
	method setActivePlayer {
		Priority = medium
		IsOptional = false
	}

	method getPlayerInfo {
		CallSemantics = synchronous
		Priority = low
		IsOptional = true
		
		out {
			name {
				Encoding = utf8
			}
			description {
				Encoding = unicode
			}
		}
	}
}
\end{lstlisting}

Note that the structure of the deployment definition resembles the structure of
the interface definition in Franca IDL itself.

\subsection{Deployment of interface providers}
\label{DeploymentModels_Definitions_Providers}
This section provides a detailed example of deployment definitions for interface
providers and interface instances. The specification for this deployment is again
located in the separate file \textit{SampleDeploySpec.fdepl}, which is imported in
the first line of the example (same as in previous example). The second line is
another import statement; it imports the actual France IDL interface which
will be referred to by the deployment data in the remaining part of this file.

The deployment definition for the provider \textit{ExampleServer} explicitly references
the specification \textit{SampleDeploySpec}. If you compare this with 
the specification from section
\hyperref[DeploymentModels_Specifications_Interfaces]{Deployment specification for interfaces~(�\ref*{DeploymentModels_Specifications_Interfaces})},
you will not find any property declarations for hosts \textit{providers} or \textit{instances}. 
These declarations are inherited from the base specification \textit{IPBasedIPC}. 
See section \hyperref[DeploymentModels_Specifications_SpecificationInheritance]{Specification Inheritance~(�\ref*{DeploymentModels_Specifications_SpecificationInheritance})}
for the inheritance feature of Franca deployment models.


\begin{lstlisting}[language=FDeploy]
import "deployspecs/SampleDeploySpec.fdepl"
import "../franca/demo1.fidl"

define SampleDeploySpec for provider ExampleServer
{
	ProcessName = "server1.exe"
	
	instance org.franca.examples.demo.PlayerAPI {
		IPAddress = "192.168.1.50"
		Port = 8765
		AccessControl = subnet
	}	

	instance org.franca.examples.demo.PlayerAPI {
		IPAddress = "192.168.1.50"
		Port = 7654
	}
}
\end{lstlisting}

In the example definition above, the component \textit{ExampleServer} is defined which provides
two instances of the same Franca interface \textit{PlayerAPI}. The instances can be addressed
with the same IP address, but different port numbers. The first instance of this interface
can be accessed by clients in the same subnet only. The second instance can be accessed
globally, because this value has been defined as default in the \textit{IPBasedIPC}-specification
and hasn't been overridden in the example above. This is just an example which shows the
difference between actual interface definitions and their instances.  

\section{Support for accessing deployment properties}
\label{DeploymentModels_DeploymentAccessSupport}
It is important that deployment properties can be accessed easily during code generation,
testcase generation and other post-processing steps. Franca provides some infrastructure
for retrieving the deployment data attached to various interface entities easily.

\subsection{PropertyAccessor classes}
\label{DeploymentModels_DeploymentAccessSupport_PropertyAccessor}
Deployment properties will always be retrieved for a given element of a Franca IDL model.
E.g., if the code generator implementation needs to access all information available for
an actual \hyperref[FrancaModelAPIReference_FAttribute]{FAttribute~(�\ref*{FrancaModelAPIReference_FAttribute})} object, it shouldn't be 
necessary to traverse the deployment model, find all properties for this attribute object,
check if there are defaults for some of these properties, type-check and cast the actual
values of the properties and much more. In order to encapsulate this functionality and
just offer a method to get a property value for a given Franca IDL model element,
Franca provides a \textit{PropertyAccessor} class, which does all the steps mentioned above.

The actual methods provided by a \textit{PropertyAccessor} class will depend on the 
underlying \hyperref[DeploymentModels_Specifications]{deployment specification~(�\ref*{DeploymentModels_Specifications})}.
As this specification is part of the deployment language and will be changed 
by the user, the \textit{PropertyAccessor} Java class will be generated by the Franca
infrastructure while editing specifications with the Eclipse IDE.

\subsection{PropertyAccessor example}
\label{DeploymentModels_DeploymentAccessSupport_PropertyAccessorExample}
The following simple example shows a deployment specification:


\begin{lstlisting}[language=FDeploy]
specification org.deployspecs.SimpleSpec
{
	for attributes {
		WillChangeOften: Boolean (optional);
	}
}
\end{lstlisting}

From this user-defined specification Franca will generate the following
\textit{PropertyAccessor} class:


\begin{lstlisting}[language=Java]
/*******************************************************************************
* This file has been generated by Franca's FDeployGenerator.
* Source: deployment spec 'org.deployspecs.SimpleSpec'
*******************************************************************************/
package org.deployspecs;

import org.franca.core.franca.FAttribute;
import org.franca.deploymodel.core.FDeployedInterface;

/**
 * Accessor for deployment properties for 'org.deployspecs.SimpleSpec' specification
 */		
public class SimpleSpecInterfacePropertyAccessor
{
	private FDeployedInterface target;

	public SimpleSpecInterfacePropertyAccessor (FDeployedInterface target) {
		this.target = target;
	}
	
	public Boolean getWillChangeOften (FAttribute obj) {
		return target.getBoolean(obj, "WillChangeOften");
	}
}
\end{lstlisting}

The method \textit{getWillChangeOften()} of the generated class \textit{SimpleSpecInterfacePropertyAccessor}
should be used to get the property value \textit{WillChangeOften} for a given attribute.
The \textit{PropertyAccessor} will retrieve the value of this property (either the actual value
or the default) and will return it in a type-safe way. This is a convenient technique
to get property data from deployment models.

\subsection{Creating InterfacePropertyAccessors}
\label{DeploymentModels_DeploymentAccessSupport_CreatingPropertyAccessor}
In order to instantiate a specific \textit{InterfacePropertyAccessor} object, 
an \textit{FDInterface} object has to be retrieved from a deployment model. 
Deployment models are represented by an \textit{FDModel} object.
The helper class \textit{FDModelExtender} provides a means to retrieve all 
interface deployment definitions of an \textit{FDModel}.

The following Java snippet loads a deployment model from file system,
creates a model extender in order to retrieve all \textit{FDInterface} objects
and creates the actual \textit{InterfacePropertyAccessor} object for each of them.


\begin{lstlisting}[language=Java]
FDModel fdmodel = FDModelHelper.instance().loadModel(inputfile);
FDModelExtender fdmodelExt = new FDModelExtender(fdmodel);
for(FDInterface fdi : fdmodelExt.getFDInterfaces()) {
	FDeployedInterface deployed = new FDeployedInterface(fdi);
	SimpleSpecInterfacePropertyAccessor accessor = new SimpleSpecInterfacePropertyAccessor(deployed);
	// use accessor, e.g., accessor.getWillChangeOften()
	
	FInterface api = fdi.getTarget();
	// call downstream tool (e.g., code generator) for FInterface 'api'
}
\end{lstlisting}

Note how the actual Franca IDL interface can be accessed from each
FDInterface (i.e., the deployment specification of an interface)
by using the \textit{getTarget()} property.

\subsection{ProviderPropertyAccessors}
\label{DeploymentModels_DeploymentAccessSupport_ProviderPropertyAccessor}
For properties related to \hyperref[DeploymentModels_Concepts_Providers]{providers and interface instances~(�\ref*{DeploymentModels_Concepts_Providers})},
another \textit{PropertyAccessor} will be generated, whose name is created as concatenation
of the deployment specification's name and the suffix \textit{ProviderPropertyAccessor}.

The creation and usage of \textit{ProviderPropertyAccessors} is similar to the usage of
\textit{InterfacePropertyAccessors} as described above.

\subsection{Example project}
\label{DeploymentModels_DeploymentAccessSupport_Examples}
The example project \textit{org.franca.examples.deploy} contains two example generators
in the package

\textit{org.franca.examples.deploy.generators}:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{ExampleHppGeneratorWithDeployment}: This example code generator shows
		how deployment information can be accessed during traversal of an actual
		Franca IDL interface.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{ExampleRuntimeConfigGenerator}: This example generator shows
		how deployment information can be accessed, which is not directly linked
		to an actual Franca IDL interface (e.g., interface providers and instances).

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}


\chapter{Building generators with Franca}
\label{BuildingGenerators}
When a company or R\&D department decides to model its interfaces
with Franca IDL then typically the interface definitions will be
utilized by downstream tools, mostly by generators creating code
or documentation from these interfaces.
This chapter gives an introduction how generators can be implemented 
which produce code and other artifacts from Franca IDL models.

\section{Introduction}
\label{BuildingGenerators_Introduction}
This introductory section describes the basic approach and some design 
decisions how to build generators based on the Franca model API.  

\subsection{Basic approach}
\label{BuildingGenerators_Introduction_Approach}
A typical approach to implement generators for Franca includes the
following steps:

\setlength{\XdocItemIndent}{\textwidth}
\begin{enumerate}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
Load a Franca IDL file (with suffix \textit{.fidl}) from file system.
         Result: a Franca model in main memory.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Generate code from the Franca model.
         Result: some text strings containing the generation output.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
Save the generation output to one or more files on the file system.

\end{minipage}
\end{enumerate}
\addtolength{\XdocItemIndent}{2.5em}

These steps will be described in more detail below.

\subsection{Which language can be used?}
\label{BuildingGenerators_Introduction_Language}
The loading step will result in an underlying Franca model which is the 
base for the generator. This model provides a \hyperref[FrancaModelAPI]{Java API~(�\ref*{FrancaModelAPI})}
generated by the
\href{http://www.eclipse.org/modeling/emf/}{Eclipse Modeling Framework (EMF)}.

Thus, Java is a good choice for the generator implementation. However, there
are other languages available which operate on the Java VM or which translate
to Java: Groovy, Scala and Xtend are some examples. All those languages can
be used to implement generators for Franca.

For developers already used to Java we recommend using
\href{http://xtend-lang.org}{Xtend} for this task.
Xtend offers a seamless integration with Java allowing the generator 
being implemented as a proper mix of Java (where necessary) and Xtend.
We fill focus on Xtend in this and later chapters; the examples being
shipped with Franca are using Xtend as well.  

\subsection{Tool integration}
\label{BuildingGenerators_Introduction_ToolIntegration}
There are various ways to integrate a generator into your toolchain.
Here are some examples:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{Generator as JUnit test case}. Usually, this is the first step
	     when implementing a new generator. In this case, the generator
	     runs on a separate Java VM without an instance of the Eclipse IDE.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{Standalone generator}. The generator is packed into a jar file
	     and called by a Java main class which offers command-line arguments
	     for configuring the generator. Also in this case, the generator
	     runs on a separate Java VM without an instance of the Eclipse IDE.
	     A standalone generator can also be integrated into some build process,
	     e.g. to be part of a continuous integration build.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{Generator as Eclipse action}. The generator is embedded into
	     an \textit{Action} class which implements \textit{org.eclipse.ui.IActionDelegate}.
	     Thus, the generator can be triggered from the Eclipse IDE, e.g. by 
	     selecting a proper context menu item.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

As this chapter puts its focus on the actual generation step, we only 
describe the JUnit-based solution here. 

\subsection{Loading a Franca IDL file}
\label{BuildingGenerators_Introduction_LoadingFrancaFile}
Loading a Franca IDL model file (with extension \textit{fidl}) from the file system is
a standard task. It is supported by the Franca Framework, here is a Java example
as part of a JUnit test:


\begin{lstlisting}[language=Java]
import static org.junit.Assert.*;
import org.franca.core.dsl.FrancaIDLHelpers;
import org.franca.core.franca.FModel;
import org.junit.Test;

public class MyTest {
	@Test
	public void loadModel() {
		FModel fmodel = FrancaIDLHelpers.instance().loadModel("example.fidl");
		assertNotNull(fmodel);

		// ... traverse model here
	}
}
\end{lstlisting}

The \textit{FrancaIDLHelpers} singleton class provides a convenient \textit{loadModel()} 
function which initializes the infrastructure needed for Franca and
loads the Franca IDL file afterwards. It might use a relative or absolute
path. If the model \textit{imports} other files, those will be loaded, too.
All cross references will be resolved. 

The function \textit{loadModel()} returns an object of type
\hyperref[FrancaModelAPIReference_FModel]{FModel~(�\ref*{FrancaModelAPIReference_FModel})} (follow the link to the 
corresponding section of the \hyperref[FrancaModelAPI]{Franca Model API~(�\ref*{FrancaModelAPI})} documentation).
See the next section for how to traverse the model and generate some artifacts from it.

\section{Traversing Franca models}
\label{BuildingGenerators_TraversingFrancaModels}
\subsection{Starting with FModel}
\label{BuildingGenerators_TraversingFrancaModels_Top}
A Franca IDL model (represented by an object of type \hyperref[FrancaModelAPIReference_FModel]{FModel~(�\ref*{FrancaModelAPIReference_FModel})}) 
might contain several type collections \hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})}
and interfaces \hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}. These can be accessed using
the generated FModel API, the following Xtend code example shows how to access them.
 

\begin{lstlisting}[language=Xtend]
class ExampleGenerator {
	def generateFromModel (FModel fmodel) {
		for(tc : fmodel.typeCollections)
			tc.generateTypes

		for(i : fmodel.interfaces)
			i.generateInterface
	}
	
	def private generateTypes (FTypeCollection types) {
		// access properties of FTypeCollection, e.g. types.name
	}

	def private generateInterface (FInterface api) {
		// access properties of FInterface, e.g. api.name or api.methods
	}
\end{lstlisting}

In the example, there is only a stub implementation for the functions \textit{generateTypes()}
and \textit{generateInterface()}.  

\subsection{Accessing an FInterface}
\label{BuildingGenerators_TraversingFrancaModels_FInterface}
The following Xtend example code shows how to traverse all methods 
(i.e., \hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})} members) of a Franca interface
\hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}.
It generates a C++ class with member function declarations for all Franca methods.


\begin{lstlisting}[language=Xtend]
def generateInterface (FInterface api) '''
	class �api.classname�
	{
	public:
		// methods
		�FOR m : api.methods�
		�m.generateMethodDecl� 
		�ENDFOR�
	};
'''
\end{lstlisting}

This function uses a \textit{template expression} (surrounded by triple single quotes), which 
is a very useful feature of Xtend when it comes to textual generators.
Template expressions can span multiple lines and contain expressions which are evaluated
and their string representation being inserted at that position.

\subsection{Benefits due to Xtend features}
\label{BuildingGenerators_TraversingFrancaModels_Xtend}
Template expressions are one useful feature of Xtend which supports the implementation
of generators very nicely. Here are some more Xtend features which are very handy
for generator developers:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
The implicit \textit{it}-variable allows to reduce syntactic sugar, especially in the
	     case of lots of small methods as usually found in generator code.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
The \textit{switch-statement for classes} allows to implement type-safe dispatching
	     without \textit{instanceof}-cascades and downcasts.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{Lambda expressions} are very useful for the traversal and filtering of 
	     object graphs (as in the Franca model).

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{Extension methods} allow to split the generator functionality into a set
	     of loosely coupled classes. This is even more valuable if used in conjunction
	     with \textit{dependency injection} based on \textit{com.google.inject.Inject}.

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
\textit{Dispatch methods} introduce a polymorphic behaviour, which is handy for dispatching
	     \textit{generate()}-calls to various subclasses in a class hierarchy
	     (e.g., look at \hyperref[FrancaModelAPIReference_FType]{FType~(�\ref*{FrancaModelAPIReference_FType})} and its subclasses.

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

There are some more nice features of Xtend which help in implementing generators. 
See the \href{http://xtend-lang.org}{documentation on Xtend} for more details on this.
It is available online and as printable pdf. 

\subsection{Next steps}
\label{BuildingGenerators_TraversingFrancaModels_NextSteps}
In the following, the Franca IDL model has to be traversed further, extracting information
from the model and generating code from it.
The typical way of implementing this is top-down, starting with
\hyperref[FrancaModelAPIReference_FModel]{FModel~(�\ref*{FrancaModelAPIReference_FModel})},
\hyperref[FrancaModelAPIReference_FTypeCollection]{FTypeCollection~(�\ref*{FrancaModelAPIReference_FTypeCollection})} and
\hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})},
and continuing with type definitions from type collections and interfaces (e.g., 
\hyperref[FrancaModelAPIReference_FType]{FType~(�\ref*{FrancaModelAPIReference_FType})} / \hyperref[FrancaModelAPIReference_FTypeRef]{FTypeRef~(�\ref*{FrancaModelAPIReference_FTypeRef})},
\hyperref[FrancaModelAPIReference_FStructType]{FStructType~(�\ref*{FrancaModelAPIReference_FStructType})},
\hyperref[FrancaModelAPIReference_FArrayType]{FArrayType~(�\ref*{FrancaModelAPIReference_FArrayType})} and many more).
Finally output is generated for the elements of interfaces (e.g., 
\hyperref[FrancaModelAPIReference_FAttribute]{FAttribute~(�\ref*{FrancaModelAPIReference_FAttribute})},
\hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})}, 
\hyperref[FrancaModelAPIReference_FBroadcast]{FBroadcast~(�\ref*{FrancaModelAPIReference_FBroadcast})} and
\hyperref[FrancaModelAPIReference_FArgument]{FArgument~(�\ref*{FrancaModelAPIReference_FArgument})}).

There are some special features in the Franca model API which should taken care of:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
inheritance for \hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})},
	     \hyperref[FrancaModelAPIReference_FStructType]{FStructType~(�\ref*{FrancaModelAPIReference_FStructType})},
	     \hyperref[FrancaModelAPIReference_FUnionType]{FUnionType~(�\ref*{FrancaModelAPIReference_FUnionType})} and
	     \hyperref[FrancaModelAPIReference_FEnumerationType]{FEnumerationType~(�\ref*{FrancaModelAPIReference_FEnumerationType})}
	     (see \textit{base}-property for these classes)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
implicit arrays, which is relevant for all subclasses of
	     \hyperref[FrancaModelAPIReference_FTypedElement]{FTypedElement~(�\ref*{FrancaModelAPIReference_FTypedElement})}
	     (via its \textit{array}-property)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
error enumerators for methods, available in two variants
	     (see \hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})})

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

We will not go into more detail here, as there is a detailed chapter on the
\hyperref[FrancaModelAPI]{Franca Model API~(�\ref*{FrancaModelAPI})} in this User Guide.

\subsection{Contract section of FInterface}
\label{BuildingGenerators_TraversingFrancaModels_Contracts}
Each Franca interface might contain a definition of a \textit{contract}, specifying the
dynamic behavior of the interface. The corresponding classes of the Franca model API
are described in the User Guide section 
\hyperref[FrancaModelAPIReference_Section_FContract]{API for Franca contracts~(�\ref*{FrancaModelAPIReference_Section_FContract})}.

As the contract is specifying the behavior of the interface, it should not contain 
any application logic. Thus, it should not be necessary to access this part of the model
when generating target code. However, in order to use the specified contract as part
of a \textit{runtime verification monitor} or for an offline trace analyser, it will be needed
to traverse this part of the model and generate some artifacts from it.

Section \hyperref[FIDL_Contracts]{Contracts~(�\ref*{FIDL_Contracts})} describes the notion of contracts and their 
syntax and usage in more detail.

\section{Accessing Franca deployment models}
\label{BuildingGenerators_AccessingFrancaDeploymentModels}
For the Franca IDL model there is the \hyperref[FrancaModelAPI]{Franca Model API~(�\ref*{FrancaModelAPI})} which allows
programmatic access to IDL models. This is also the recommend way for building generators
from Franca IDL.
For \hyperref[DeploymentModels]{Franca deployment models~(�\ref*{DeploymentModels})}, there is also an API generated by the
EMF infrastructure. However, we discourage using this API because deployment models are far more
generic than IDL models and contain many implicit assumptions and logical constraints. 
In order to work with deployment models programmatically, \textit{PropertyAccessor} classes
should be used.

As this is not specific to building generators, but will be needed also for model-to-model
transformations and other Franca IDL downstream processing tasks, please refer to common section 
\hyperref[DeploymentModels_DeploymentAccessSupport]{Support for accessing deployment properties~(�\ref*{DeploymentModels_DeploymentAccessSupport})}
to get the details of accessing Franca deployment models from your generator implementation.


\chapter{Building transformations to/from Franca}
\label{BuildingTransformations}
One particular sweet spot for Franca is its ability to integrate software systems
by supporting transformations from other interface definition languages to Franca IDL.
This chapter describes some concepts around this topic and details how those
transformations can be designed and implemented.

\section{Introduction}
\label{BuildingTransformations_Introduction}
Software interfaces which are modeled using some other technology than Franca
can be mapped to Franca by providing a model-to-model transformation. This can be done 
in two directions:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
from Franca IDL to another IDL

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
from another IDL to Franca IDL

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

A \textit{Franca connector} is a Java class which contains both transformations for a
given IDL. Usually, the other IDL will be modeled based on some meta-model. 
In many environments an \textit{ecore}-model of the IDL is available
(which is a meta-model in the format given by the
\href{http://www.eclipse.org/modeling/emf/}{Eclipse Modeling Framework, short: EMF}).
If the other IDL is modeled using some XML-based format, an XML schema or a 
DTD is available, which can be converted automatically to an \textit{ecore}-model.

Based on the \textit{ecore}-model, the transformations can be implemented using
any technology which can access either the models directly or uses the
Java API of the \textit{ecore}-model as generated by EMF. Options are:

\setlength{\XdocItemIndent}{\textwidth}
\begin{itemize}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
use plain Java or another JVM-based language

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
use \href{http://xtend-lang.org}{Xtend} (maybe mixed with Java),
	     which will be transformed into Java automatically

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
use a declarative M2M framework, e.g. ATL

\end{minipage}
\end{itemize}
\addtolength{\XdocItemIndent}{2.5em}

In the following we recommend using \href{http://xtend-lang.org}{Xtend} for this task.
It has several nice features which especially support the implementation of
imperative model-to-model transformations.

\section{Transforming Franca to other models}
\label{BuildingTransformations_FrancaToX}
\subsection{Plain transformations of Franca IDL}
\label{BuildingTransformations_FrancaToX_Plain}
Implementing a plain transformation from Franca IDL models to other models is very similar to
the task of building a generator for Franca IDL. In both cases, a Franca model has to be 
traversed; the extracted information is used to produce a resulting artifact (either generated
code or another model). See the chapter on \hyperref[BuildingGenerators]{Building generators with Franca~(�\ref*{BuildingGenerators})}
for more insights about this topic.

\href{http://xtend-lang.org}{Xtend} has proven to be a powerful and expressive language for
traversing a model and constructing another model from it. There are a couple of
\hyperref[BuildingGenerators_TraversingFrancaModels_Xtend]{features supporting model traversal~(�\ref*{BuildingGenerators_TraversingFrancaModels_Xtend})}.
Another Xtend feature especially for constructing models as graphs of objects are
\textit{create-functions}. These provide a cache mechanism to avoid constructing the identical
object twice. See the Xtend reference documentation for details. An example on how
to use \textit{create-functions} can be found \hyperref[BuildingTransformations_XToFranca_Plain]{below~(�\ref*{BuildingTransformations_XToFranca_Plain})}.

Example: The plugin \textit{org.franca.connectors.dbus} is part of the Franca release. It contains
the transformation from Franca to DBus introspection files implemented in Xtend.
This can serve as an example for implementing this kind of transformation.
You will find it in Xtend file \textit{Franca2DBusTransformation.xtend} in package
\textit{org.franca.connectors.dbus}.

\subsection{Transforming Franca deployment models}
\label{BuildingTransformations_FrancaToX_WithDeployment}
If a model has to be created from Franca deployment models (including a reference to
an Franca IDL model), two models have to be traversed simultaneously. Again, this is 
a topic which is very similar to generating code from Franca deployment models.

For the Franca IDL model there is the \hyperref[FrancaModelAPI]{Franca Model API~(�\ref*{FrancaModelAPI})} which allows
programmatic access to IDL models. This is also the recommend way for building transformations
from Franca IDL.
For \hyperref[DeploymentModels]{Franca deployment models~(�\ref*{DeploymentModels})}, there is also an API generated by the
EMF infrastructure. However, we discourage using this API because deployment models are far more
generic than IDL models and contain many implicit assumptions and logical constraints. 
In order to work with deployment models programmatically, \textit{PropertyAccessor} classes
should be used.

As this is not specific to building model-to-model transformations, but will be needed
also for building generators and other Franca IDL downstream processing tasks,
please refer to common section 
\hyperref[DeploymentModels_DeploymentAccessSupport]{Support for accessing deployment properties~(�\ref*{DeploymentModels_DeploymentAccessSupport})}
to get the details of accessing Franca deployment models from your transformation implementation.

\section{Transforming other models to Franca}
\label{BuildingTransformations_XToFranca}
\subsection{Plain transformation to Franca IDL}
\label{BuildingTransformations_XToFranca_Plain}
The typical structure of a transformation of another model into Franca IDL looks
like the following:

\setlength{\XdocItemIndent}{\textwidth}
\begin{enumerate}
\addtolength{\XdocItemIndent}{-2.5em}
\item \begin{minipage}[t]{\XdocItemIndent}
load the source model from file system (or a different source)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
traverse the source model starting from the root (this is typically a top-down traversal)

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
extract information from the source model elements and create a Franca IDL model

\end{minipage}
\item \begin{minipage}[t]{\XdocItemIndent}
save the resulting Franca IDL model or use it for further processing

\end{minipage}
\end{enumerate}
\addtolength{\XdocItemIndent}{2.5em}

During the third step elements of the Franca IDL model have to be created and
filled with data. The Java class \textit{FrancaFactory} has to be used for element creation.
See section \hyperref[FrancaModelAPIReference_FactoryAndPackage]{FrancaFactory and FrancaPackage~(�\ref*{FrancaModelAPIReference_FactoryAndPackage})}
for more information on how to do this.

In the context of an Xtend implementation of a transformation, \textit{create-functions} can
be used to create the proper objects and initialize them. Here is an example showing 
a create function for \hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}.


\begin{lstlisting}[language=Xtend]
// this function will return an object of type FInterface
def create FrancaFactory::eINSTANCE.createFInterface transform(InterfaceType src) {
	// interface name is just a string and doesn't have to be transformed
	name = src.name
	
	// transform interface methods one-by-one
	methods.addAll(src.method.map [transformMethod])

	// transform further elements of 'src' and store them in the new FInterface object
	// ...
	
	// implicit return parameter 'it' (the new FInterface object)
}
\end{lstlisting}

\textit{InterfaceType} is the class corresponding to \textit{FInterface} from the source model
of the transformation (most likely another IDL). When the \textit{transform()}-method is
being called, it will first check if the source element has been transformed before.
Only if it hasn't been transformed yet, a new \hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}
object will be created. The implicit variable \textit{it} has to be used to refer to this object.
In the assignment \textit{name = src.name} the left-hand side is a property of 
\hyperref[FrancaModelAPIReference_FInterface]{FInterface~(�\ref*{FrancaModelAPIReference_FInterface})}, this is a short-hand for \textit{it.name}.

The second line calls uses \textit{lambda functions} (another handy Xtend feature) in order
to call \textit{transformMethod()} for each member of the collection \textit{src.method} and store
the resulting objects (of type \hyperref[FrancaModelAPIReference_FMethod]{FMethod~(�\ref*{FrancaModelAPIReference_FMethod})}) into the
list \textit{it.methods}. This is another pattern typically used in model transformations
implemented with \href{http://xtend-lang.org}{Xtend}.

Detailed example: The plugin \textit{org.franca.connectors.dbus} is part of the Franca release. It contains
the transformation from DBus introspection files to Franca IDL implemented in Xtend.
This can serve as an example for implementing this kind of transformation.
You will find it in Xtend file \textit{DBus2FrancaTransformation.xtend} in package
\textit{org.franca.connectors.dbus}.

\subsection{Creating additional deployment models}
\label{BuildingTransformations_XToFranca_WithDeployment}
It sometimes is necessary to transform a third-party model into two resulting models:
a Franca IDL model and a corresponding Franca deployment model. The first part of this
transformation has been covered by the previous section. In order to create the deployment
model, the helper class \textit{DeployModelBuilder} should be used. It provides helper functions
for setting deployment properties according to a given deployment specification.

In Xtend code, the \textit{DeployModelBuilder} can be imported as a static extension:

\protect\lstinline[language=Xtend]{import static extension org.franca.deploymodel.core.DeployModelBuilder.*}
 
Here is an Xtend code example showing the basic idea of creating IDL model and
deployment model at the same time (the types of the variables could be omitted
and are here for clarity only):


\begin{lstlisting}[language=Xtend]
// load deployment model containing specification(s) and get the first one
var fdSpecifications = FDModelHelper::instance.loadModel("deployspec.fdepl")
var FDSpecification fdSpec = fdSpecifications.specifications.get(0)

// create Franca IDL model and deployment model
var FModel fModel = FrancaFactory::eINSTANCE.createFModel
var FDModel fdModel = FDeployFactory::eINSTANCE.createFDModel

// prepare DeployModelBuilder

// transform all interfaces
for(src : sourceModel.interfaces) {
	var FInterface result = src.transform
	
	// create deployment model element and add it to deployment model
	var FDInterface fdInterface = FDeployFactory::eINSTANCE.createFDInterface
	fdModel.deployments.add(fdInterface)
	
	// link deployment interface to IDL interface
	fdInterface.target = result
	
	// check properties in the source model and add them to deployment model
	if (src.checkSomeProperty()) {
		// set a deployment property (this uses DeployModelBuilder)
		fdInterface.setProperty(fdSpec, "SomeProperty", true)
	}	
	// ... check more properties and set them, if necessary 
}
\end{lstlisting}

Note that the \textit{setProperty()} function is defined as part of \textit{DeployModelBuilder}
and is called for a deployment model element (here: \textit{fdInterface}). The following
parameters are: the underlying deployment specification (here: \textit{fdSpec}), the
actual name of the property (here: "SomeProperty"), and the new value for the property.
If the new value for the property is equal to the default as defined in the 
deployment specification, \textit{DeployModelBuilder} will not set the property. 

See the Javadoc documentation of \protect\lstinline�org.franca.deploymodel.core.DeployModelBuilder�
to understand all kinds of functions it offers.

Depending on the complexity of the source model, it might be tedious to create the
Franca IDL model and the deployment model at the same time. The difficult detail
is to set the \textit{target} attribute for all elements of the deployment model (see
example above).
Xtend \textit{extension methods} and Google's dependency injection framework might help
here by allowing to separate the Franca IDL model construction from the deployment
model construction (see \textit{com.google.inject} and the \textit{@Inject} annotation for
Java and Xtend).

There is no example for this kind of transformation in the Franca release yet.
This will be added in a future version.


\chapter{Franca connectors}
\label{FrancaConnectors}
The integration of Franca with other IDLs or (more generally:) models is
supported by \textit{Franca connectors}. A \textit{connector} is yet another Eclipse plugin,
which offers means to load and save models of the other IDL and transformations
to and from Franca IDL models.

This chapter lists the connectors that are currently supported by Franca out of the box.
The connectors can be selected during installation by choosing an additional feature
provided by the Franca update site.

Note that most connectors will require additional plugins which provide the model or API
(or both) for the 3rd party IDL. Thus, for installing some of those connector features,
it may be necessary to install the required plugins first.

\section{Franca support for D-Bus Introspection}
\label{FrancaConnectors_DBus}
\textit{D-Bus Introspection} is an XML format which defines D-Bus interfaces.
More details on the D-Bus IPC and D-Bus Introspection can be found
\href{http://www.freedesktop.org/wiki/Software/dbus}{at freedesktop.org}.

The Franca connector plugin for D-Bus is called \textit{org.franca.connectors.dbus}.
It requires the plugin \textit{model.emf.dbusxml}, which is available as open-source
project \textit{dbus-emf-model}
\href{http://code.google.com/a/eclipselabs.org/p/dbus-emf-model/}{on Eclipse Labs}.
An update site is available for \textit{dbus-emf-model}:

\href{http://dbus-emf-model.eclipselabs.org.codespot.com/git/update_site/releases/}{
	 http://dbus-emf-model.eclipselabs.org.codespot.com/git/update\_site/releases/}

If you install the \textit{Franca D-Bus support Feature} via \textit{Help > Install New Software...},
the \textit{model.emf.dbusxml} plugin will be installed automatically from this update site.


\chapter{Franca extensions}
\label{FrancaExtensions}
\section{Adding validators}
\label{FrancaExtensions_Validators}
\section{Providing deployment specifications}
\label{FrancaExtensions_ImplicitDeploymentSpecs}
\chapter{List of External Links}
\noindent\url{http://www.eclipse.org/xtext}
\noindent\url{http://code.google.com/a/eclipselabs.org/p/dbus-emf-model/}
\noindent\url{http://code.google.com/a/eclipselabs.org/p/franca/wiki/FrancaQuickInstallGuide}
\noindent\url{http://www.harman.com}
\noindent\url{http://xtend-lang.org}
\noindent\url{http://www.xtend-lang.org}
\noindent\url{http://www.itemis.de}
\noindent\url{http://www.freedesktop.org/wiki/Software/dbus}
\noindent\url{http://www.eclipse.org/legal/epl-v10.html}
\noindent\url{http://5ise.quanxinquanyi.de/2012/01/13/xtext-end-user-domain-experts-cheat-sheet/}
\noindent\url{http://dbus-emf-model.eclipselabs.org.codespot.com/git/update_site/releases/}
\noindent\url{http://www.eclipse.org/modeling/emf/}

\listoftodos
\end{document}
